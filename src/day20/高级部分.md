# 函数式编程

先看看什么是函数。函数是一种最基本的任务，一个大型程序就是一个顶层函数调用若干底层函数，这些被调用的

函数又可以调用其他函数，即大任务被一层层拆解并执行。所以函数就是面向过程的程序设计的基本单元。

Java不支持单独定义函数，但可以把静态方法视为独立的函数，把实例方法视为自带`this`参数的函数。

函数式编程（Functional Programming） 最早是数学家阿隆佐·邱奇研究的一套函数变换逻辑，又称Lambda 

Calculus（λ-Calculus），所以也经常把函数式编程称为Lambda计算。

函数式编程的特点就是允许把函数本身作为参数传入另一个函数，还允许返回一个函数。

Java平台从Java 8开始，支持函数式编程。

## Lambda

### Lambda -- 基础语法

Lambda表达式语法：

```java
( parameters ) -> { statements; }
```

其中 ( ) 用来描述参数列表，{ } 用来描述方法体，-> 为 lambda运算符 ，读作(goes to)。

Lambda 表达式可以对某些接口进行简单的实现，但并不是所有的接口都可以使用 Lambda 表达式来实现。

Lambda 规定接口中只能有一个需要被实现的方法(不是规定接口中只能有一个方法)，

`JDK` 中有大量这种单方法接口，例如：

- Comparator
- Runnable
- Callable

以`Comparator`为例，要调用`Collections.sort()`时，可以传入一个`Comparator`实例，采用匿名内部类的

写法如下：

```java
		List<String> list=new ArrayList<String>();
		list.add("12");
		list.add("100");
		list.add("22");
		list.add("32");
		list.add("321");
		list.add("22");
		Collections.sort(list,new Comparator<String>() { //匿名内部类实现
			public int compare(String o1, String o2) {
				// TODO Auto-generated method stub
				return Integer.parseInt(o1)-Integer.parseInt(o2);
			}
		});
```



上述写法非常繁琐。从Java 8开始，我们可以用Lambda表达式替换单方法接口，改写如下：

```java
		List<String> list=new ArrayList<String>();
		list.add("12");
		list.add("100");
		list.add("22");
		list.add("32");
		list.add("321");
		list.add("22");	
		//Lambda表达式实现
		Collections.sort(list,(String o1,String o2)-> 
			{return Integer.parseInt(o1)-Integer.parseInt(o2);});
		for(String s:list){
			System.out.println(s);
		}
```



对单方法接口，可以使用注解`@FunctionalInterface`修饰，这种接口也称之为函数式接口。 

例如：

```java
@FunctionalInterface
interface ITest{
	void m1();
}

public class LambdaDemo {
	public void method(ITest t){
		t.m1();
	}
	@Test
	public void testMethod() throws Exception{
		method(()->{System.out.println("ok");});
	}
}
```



### Lambda -- 语法简化

1. 简化参数类型：可以不写参数类型，但是必须所有参数都不写，编译器会自动推断数据类型。

   例如，接口定义：

   ```java
   @FunctionalInterface
   public interface NoReturnMultiParam {
       void method(int a, int b);
   }
   ```

   

   测试代码：

   ```java
   NoReturnMultiParam lamdba1 = (a, b) -> {
   	System.out.println("简化参数类型");
   };
   lamdba1.method(1, 2);
   ```

   

2. 简化参数小括号：如果只有一个参数则可以省略参数小括号。

   例如，接口定义：

   ```java
   @FunctionalInterface
   public interface NoReturnOneParam {
       void method(int a);
   }
   ```

   

   测试代码：

   ```java
   NoReturnOneParam lambda2 = a -> {
   	System.out.println("简化参数小括号");
   };
   lambda2.method(1);
   ```

   

3. 简化方法体大括号：如果方法体只有一条语句，则可以省略方法体大括号。

   例如，接口定义：

   ```java
   @FunctionalInterface
   public interface NoReturnNoParam {
       void method();
   }
   ```

   

   测试代码：

   ```java
   NoReturnNoParam lambda3 = () -> System.out.println("简化方法体大括号");
   lambda3.method();
   ```

   

4. 简化`return`：如果方法体只有一条语句，并且是`return`语句，则可以省略`return`和方法体大括号。

   例如，接口定义：

   ```java
   @FunctionalInterface
   public interface ReturnOneParam {
       int method(int a);
   }
   ```

   

   测试代码：

   ```java
   ReturnOneParam lambda4 = a -> a+3;
   System.out.println(lambda4.method(5));
   ```



### Lambda -- 方法引用

所谓方法引用，是指如果某个方法签名和接口中的方法恰好一致，就可以直接传入方法引用。

1. 引入静态方法

   例如：

   ```java
   public class MethodRef {
   	public static void main(String[] args) {
           String[] array = new String[] { "Apple", "Orange", "Banana", "Lemon" };
           Arrays.sort(array, MethodRef::cmp);
           System.out.println(String.join(", ", array));
       }
       static int cmp(String s1, String s2) {
           return s1.compareTo(s2);
       }
   }
   ```

   

   上述代码在`Arrays.sort()`中直接传入了静态方法`cmp`的引用，用`MethodRef::cmp`表示。

   因为`Comparator<String>`接口中的方法`int compare(String, String)`，和静态方法

   `int cmp(String, String)`相比，除了方法名外，方法参数一致，返回类型相同，因此，可以认为两者的

   方法签名一致，可以直接把方法名作为Lambda表达式传入：

   ```
   Arrays.sort(array, MethodRef::cmp);
   ```

   注意：在这里，方法签名只看参数类型和返回类型，不看方法名称，也不看类的继承关系。

2. 引入成员方法

   改写上面的代码：

   ```java
   public class MethodRef {
   	public static void main(String[] args) {
   		String[] array = new String[] { "Apple", "Orange", "Banana", "Lemon" };
   		Arrays.sort(array, String::compareTo);
   		System.out.println(String.join(", ", array));
   	}
   }
   ```

   

   运行结果是一样的，这说明`String.compareTo()`方法也符合Lambda定义。

   观察`String.compareTo()`的方法定义：

   ```java
   public final class String {
       public int compareTo(String o) {
           ...
       }
   }
   ```

   

   这个方法的签名只有一个参数，为什么和`int Comparator<String>.compare(String, String)`能匹配

   呢？因为成员方法有一个隐含的`this`参数，`String`类的`compareTo()`方法在实际调用的时候，第一个

   隐含参数总是传入`this`，相当于静态方法：

   ```java
   public static int compareTo(this, String o);
   ```

   所以，`String.compareTo()`方法也可作为方法引用传入。

3. 引入构造方法

   ```java
   class Student {
       String name;
       public Student(String name) {
           this.name = name;
       }
       public String toString() {
           return "Student:" + this.name;
       }
   }
   public class MethodRef {
   	public static void main(String[] args) {
           List<String> names = Arrays.asList(new String[] {"Mike", "Peter", "Tom"});
           List<Student> persons = 
           		names.stream().map(Student::new).collect(Collectors.toList());
           System.out.println(persons);
       }
   }
   ```

   

   这里的`map()`需要传入的`FunctionalInterface`的定义是：

   ```
   @FunctionalInterface
   public interface Function<T, R> {
       R apply(T t);
   }
   ```

   把泛型对应上就是方法签名`Student apply(String)`，即传入参数`String`，返回类型`Student`。

   而`Student`类的构造方法恰好满足这个条件，因为构造方法的参数是`String`，而构造方法虽然没有

   `return`语句，但它会隐式地返回`this`实例，类型就是`Student`，因此，此处可以引用构造方法。

   构造方法的引用写法是`类名::new`，因此，此处传入`Student::new`。

## Stream

Java从8开始，引入了一个全新的流式 API：`Stream`。它位于`java.util.stream`包中。其代表的是任意Java对

象的队列。这个`Stream`和`List`不一样，`List`存储的每个元素都是已经存储在内存中的，而`Stream`输出的

元素可能并没有预先存储在内存中，而是实时计算出来的。

换句话说，`List`的用途是操作一组已存在的Java对象，而`Stream`实现的是惰性计算，两者对比如下：

|      | java.util.List           | java.util.stream     |
| ---- | ------------------------ | -------------------- |
| 元素 | 已分配并存储在内存       | 可能未分配，实时计算 |
| 用途 | 操作一组已存在的Java对象 | 惰性计算             |

举个例子：如果在程序中要定义一个全体自然数的集合，显然用`List`是不可能写出来的，因为自然数是无限的，

内存再大也没法放到`List`中，但是，用`Stream`可以做到。写法如下：

```java
Stream<BigInteger> naturals = createNaturalStream(); // 全体自然数
```

暂不考虑`createNaturalStream()`这个方法如何实现，先看看如何使用这个`Stream`。

首先，可以对每个自然数做一个平方，这样就把这个`Stream`转换成了另一个`Stream`：

```java
Stream<BigInteger> naturals = createNaturalStream(); // 全体自然数
Stream<BigInteger> streamNxN = naturals.map(n -> n.multiply(n)); // 全体自然数的平方
```

因为这个`streamNxN`也有无限多个元素，要打印它，必须首先把无限多个元素变成有限个元素，可以用

`limit()`方法截取前100个元素，最后用`forEach()`处理每个元素，这样，就打印出了前100个自然数的平方：

```java
Stream<BigInteger> naturals = createNaturalStream();
naturals.map(n -> n.multiply(n)) // 1, 4, 9, 16, 25...
        .limit(100)
        .forEach(System.out::println);
```

总结一下`Stream`的特点：它可以“存储”有限个或无限个元素。这里的存储打了个引号，是因为元素有可能已经全

部存储在内存中，也有可能是根据需要实时计算出来的。

`Stream`的另一个特点是，一个`Stream`可以轻易地转换为另一个`Stream`，而不是修改原`Stream`本身。

最后，真正的计算通常发生在最后结果的获取，也就是惰性计算。

```java
Stream<BigInteger> naturals = createNaturalStream(); //不计算
Stream<BigInteger> s2 = naturals.map(BigInteger::multiply); //不计算
Stream<BigInteger> s3 = s2.limit(100); // 不计算
s3.forEach(System.out::println); // 计算
```

惰性计算的特点是：一个`Stream`转换为另一个`Stream`时，实际上只存储了转换规则，并没有任何计算发生。

上面的例子中，创建一个全体自然数的`Stream`，不会进行计算，把它转换为上述`s2`这个`Stream`，也不会进行

计算。再把`s2`这个无限`Stream`转换为`s3`这个有限的`Stream`，也不会进行计算。只有最后，调用`forEach`

确实需要`Stream`输出的元素时，才进行计算。通常把`Stream`的操作写成链式操作，代码更简洁：

```java
createNaturalStream()
    .map(BigInteger::multiply)
    .limit(100)
    .forEach(System.out::println);
```

因此，Stream API的基本用法就是：创建一个`Stream`，然后做若干次转换，最后调用一个求值方法获取真正计算

的结果：

```java
int result = createNaturalStream() // 创建Stream
             .filter(n -> n % 2 == 0) // 任意个转换
             .map(n -> n * n) // 任意个转换
             .limit(100) // 任意个转换
             .sum(); // 最终计算结果
```

### Stream -- 获取

1. Stream.of()

   创建`Stream`最简单的方式是直接用`Stream.of()`静态方法，传入可变参数即创建了一个能输出确定元素

   的`Stream`。

   例如：

   ```java
   	public static void main(String[] args) {
   		Stream<String> stream = Stream.of("A", "B", "C", "D");
             stream.forEach(System.out::println);
   	}
   ```

   

2. 基于数组或Collection

   第二种创建`Stream`的方法是基于一个数组或者`Collection`，这样该`Stream`输出的元素就是数组或者

   `Collection`持有的元素。

   例如：

   ```java
   	public static void main(String[] args) {
   		List<String> list=new ArrayList<>();
   		list.add("X");
   		list.add("Y");
   		list.add("Z");
   		Stream<String> stream1 = Arrays.stream(new String[] { "A", "B", "C" });
             Stream<String> stream2 = list.stream();
             stream1.forEach(System.out::println);
             stream2.forEach(System.out::println);
   	}
   ```

   

3. 基于Supplier

   创建`Stream`还可以通过`Stream.generate()`方法，它需要传入一个`Supplier`对象：

   ```
   Stream<String> s = Stream.generate(Supplier<String> sp);
   ```

   基于`Supplier`创建的`Stream`会不断调用`Supplier.get()`方法来不断产生下一个元素，这种`Stream`

   保存的不是元素，而是算法，它可以用来表示无限序列。

   例如：

   ```java
   public class Demo03 {
   	public static void main(String[] args) {
           Stream<Integer> natual = Stream.generate(new NatualSupplier());
           // 注意：无限序列必须先变成有限序列再打印
           natual.limit(20).forEach(System.out::println);
       }
   }
   class NatualSupplier implements Supplier<Integer> {
       int n = 0;
       public Integer get() {
           n++;
           return n;
       }
   }
   ```

   

### Stream -- 操作

#### forEach

`forEach`用来迭代流中的每个数据

例如：

```java
	public static void main(String[] args) {
		List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
		numbers.stream().forEach(System.out::println);
	}
```



#### map

`Stream.map()`是`Stream`最常用的一个转换方法，它把一个`Stream`转换为另一个`Stream`。

所谓`map`操作，就是把一种操作运算，映射到一个序列的每一个元素上。

例如：

```java
	public static void main(String[] args) {
		List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
		//每个数转成其平方
		numbers.stream().map(i->i*i).forEach(System.out::println);
	}
```



#### filter

`Stream.filter()`是`Stream`的另一个常用转换方法。

所谓`filter()`操作，就是对一个`Stream`的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足

条件的元素就构成了一个新的`Stream`。

例如：

```java
	public static void main(String[] args) {
		List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
		//过滤出大于3的数
		numbers.stream().filter(i->i>3).forEach(System.out::println);
	}
```



#### sorted

sorted 方法用于对流进行排序。

例如：

```java
	public static void main(String[] args) {
		List<String> strs = Arrays.asList("21", "2", "13", "33", "25", "6");
		//按照字符串所包含数字的大小进行排序
		strs.stream()
			.sorted((a,b)->Integer.parseInt(a)-Integer.parseInt(b))
			.forEach(System.out::println);
	}
```



#### limit

limit 方法用于获取指定数量的元素。

```java
	public static void main(String[] args) {
		Random random = new Random();
		//打印前10个随机数
		random.ints().limit(10).forEach(System.out::println);
	}
```



#### parallel

通常情况下，对`Stream`的元素进行处理是单线程的，即一个一个元素进行处理。但是很多时候，我们希望可以

并行处理`Stream`的元素，因为在元素数量非常大的情况，并行处理可以大大加快处理速度。把一个普通

`Stream`转换为可以并行处理的`Stream`非常简单，只需要用`parallel()`进行转换，或者直接使用

`parallelStream()`获得并行流。只要可能，并行流就会对后续操作进行并行处理。我们不需要编写任何多线程

代码就可以享受到并行处理带来的执行效率的提升。

例如：

```java
	public static void main(String[] args) {
		List<String> strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");
		//使用并行流获取空字符串的数量
		//long count = strings.parallelStream().filter(string -> string.isEmpty()).count();
		long count = strings.stream().parallel().filter(string -> string.isEmpty()).count();
		System.out.println("count:"+count);
	}
```



#### Collectors

`Collectors` 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串。

例如：

```java
	public static void main(String[] args) {
		List<String> strings = Arrays.asList("abc", "", "bc", "efg", "abcd", "", "jkl");
		List<String> filtered = strings
				.stream()
				.filter(string -> !string.isEmpty())
				.collect(Collectors.toList());
		System.out.println("筛选列表: " + filtered); //筛选列表: [abc, bc, efg, abcd, jkl]
		String mergedString = strings
				.stream()
				.filter(string -> !string.isEmpty())
				.collect(Collectors.joining(", "));
		System.out.println("合并字符串:"+mergedString); //合并字符串: abc, bc, efg, abcd, jkl
	}
```



# 多线程

## 多任务处理

### 多任务处理模式

多任务处理模式有2种：协同式和抢占式。

- 协同式：CPU的分配直接由应用程序决定，所以系统性能好坏取决于应用程序设计好坏。

- 抢占式：各进程占用CPU的时间由系统调度程序决定，当调度程序检测出有比当前任务优先级更高的程序事件

  后，暂停当前任务并将CPU时间分配给优先级更高的进程。Linux、windows都采用抢占式。

### 多任务处理实现

多任务处理的实现有两种：

1. 基于进程

   在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，进程由操作

   系统直接管理，直接运行。进程有自己的地址空间，每一个进程开启都会消耗内存、占用CPU。基于进程的

   特点是允许计算机同时运行两个或多个程序。Linux、windows就是支持多任务的操作系统，比起单任务系统

   它的功能增强了许多。在windows的任务管理器中，能看到当前同时运行的多个进程信息：

   ![1607397041164](D:/上课/网课/文档/JavaSE/image/82728f13-63da-461b-b27f-d6a071dad8ff.png)

   对单核CPU，同时运行多个进程就是让CPU对多个进程轮流交替执行。

   例如，让浏览器执行5毫秒，让钉钉执行5毫秒，再让QQ音乐播放器执行5毫秒，在人看来，CPU就是在同时执

   行多个任务。即使是多核CPU，因为通常任务的数量远远多于CPU的核数，所以进程也是交替执行的。

2. 基于线程 

   某些进程内部也需要同时执行多个子任务。例如，在使用Word时，可以一边打字，一边进行拼写检查，

   同时还可以进行后台打印；这种子任务称之为线程。一条线程指的是进程中一个单一顺序的控制流，一个进

   程中可以并发多个线程，每条线程并行执行不同的任务，多个线程共享一个进程的内存空间。

   操作系统调度的最小任务单位是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线

   程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。

3. 多进程 vs 多线程

   和多线程相比，多进程的缺点在于：

   - 创建进程比创建线程开销大

   - 进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快

   而多进程的优点在于：

   多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况

   下，任何一个线程崩溃会直接导致整个进程崩溃。

## 多线程

JAVA语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行`main()`方

法，在`main()`方法内部，我们又可以启动多个子线程。此外，JVM进程中还有负责垃圾回收的其他子线程。

每个子线程可以看做由3部分构成：

1. 一段可以独立运行的代码

2. 其所操作的数据

3. CPU时间片

![1607399796493](D:/上课/网课/文档/JavaSE/image/e312469a-3e18-4687-a13e-7dd858290e6a.png)

### 多线程的实现

#### 继承Thread类

Thread表示程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。 

创建新执行线程的一种方法是将类声明为 `Thread` 的子类。该子类应重写 `Thread` 类的 `run` 方法。

接下来可以创建并启动该子类的实例。

Thread类的方法：

![1607407104222](D:/上课/网课/文档/JavaSE/image/ee0c404b-2e89-40f5-8476-5619fc919195.png)

![1607406570647](D:/上课/网课/文档/JavaSE/image/7024a076-9c4e-4acb-ae7d-a901263e52cc.png)

![1607407186651](D:/上课/网课/文档/JavaSE/image/b9e0bdbc-662c-4dc0-9cde-2f2e1248c8ea.png)

![1607407403695](D:/上课/网课/文档/JavaSE/image/6b716062-14a6-40dd-8e81-783f76098f76.png)

例如：

```java
class MyThread01 extends Thread{
	public void run() { //重写run()方法
		Thread t=Thread.currentThread();//获得子线程对象
		while(true){
			try {
				Thread.sleep(1000);//当前线程暂停1000毫秒，也就是1秒
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(t.getName());//控制台打印线程名称
		}
	}
}
```



测试方法：

```java
	public static void main(String[] args) {	
		//new MyThread().run();//不会报错，但只是普通方法的调用,不会启动新的线程
		new MyThread01().start();//启动子线程,执行run()里的代码
		Thread t=Thread.currentThread();//获得主线程对象
		while(true){
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println(t.getName());//控制台打印线程名称
		}
	}
```



执行结果：

```txt
main
Thread-0
main
Thread-0
Thread-0
main
main
Thread-0
Thread-0
```



能够看到轮流打印出子线程和主线程的名字，其顺序和间隔都是不固定的。

#### 实现Runnable接口

```java
class MyThread02 implements Runnable{
	public void run() {
		Thread t=Thread.currentThread();
		while(true){
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(t.getName());
		}
	}
}
```



测试方法：

```java
	public static void main(String[] args) {	
		new Thread(new MyThread02()).start();//启动子线程
		Thread t=Thread.currentThread();
		while(true){
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(t.getName());
		}
	}
```



运行结果依然是轮流打印出子线程和主线程的名字。

#### 实现Callable接口

与使用Runnable相比， Callable功能更强大

1. 相比run()方法，可以有返回值
2. 方法可以抛出异常 
3. 支持泛型的返回值 
4. 需要借助FutureTask类，比如获取返回结果

Future接口

1. 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。

2. FutrueTask是Futrue接口的唯一的实现类

3. FutureTask 同时实现了Runnable, Future接口。它既可以作为 Runnable被线程执行，又可以作为Future得到   

   Callable的返回值

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

class MyCallable implements Callable<Integer> {//1.创建一个实现Callable的实现类
	@Override
	public Integer call() throws Exception {// 2.实现call方法,将此线程需要执行的操作些在这里
		int sum = 0;
		for (int i = 1; i <= 10; i++) {
			if (i % 2 == 0) {
				try {
					Thread.sleep(1);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(i);
				sum += i;
			}
		}
		return sum;
	}
}
public class CallableTest {
	public static void main(String[] args) {
		// 3.创建Callable接口实现类的对象
		MyCallable call = new MyCallable();
		// 4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
		FutureTask<Integer> futureTask = new FutureTask<>(call);
		// 5.FutureTask的对象作为参数传递到Thread类的构造器中创建Thread，并调用start()
		new Thread(futureTask).start();//启动子线程开始计算
		try {
			Thread.sleep(1);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("主线程开始做其它的事情");
		try {
			Object sum = futureTask.get();//获得子线程执行完毕返回的结果
			System.out.println("总和为" + sum);
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (ExecutionException e) {
			e.printStackTrace();
		}
	}
}
```



执行结果:

```txt
2
主线程开始做其它的事情
4
6
8
10
总和为30
```



主线程和子线程是并行执行，每次执行的结果可能会不同

### 线程的状态

![1607671364670](D:/上课/网课/文档/JavaSE/image/4ff3b570-7623-4937-a108-46ba02fd6abf.png)

- 新建:

  使用 **new** 关键字创建了一个线程对象后，该线程对象就处于新建状态。

- 可运行:

  当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里

  线程调度器的调度。

- 正在运行:

  如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。

- 阻塞:

  如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进

  入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。

- 终止:

  一个运行状态的线程执行完 **run()** 方法里的代码，该线程就切换到终止状态。

#### 线程阻塞

sleep() 和 join() 都能造成阻塞，前面的代码中已经演示过 sleep() 的用法，接下来学习join的用法：

![1607497073778](D:/上课/网课/文档/JavaSE/image/a84728c8-2464-41b4-a154-4bc09dc21b46.png)

当`main`线程对线程对象`t`调用`join()`方法时，主线程将等待变量`t`表示的线程运行结束（或等待指定的时

间），即`join`就是指等待`t`线程结束，然后才继续往下执行`main`线程。

例如：

```java
class MyThread03 implements Runnable{
	public void run() {
		Thread t=Thread.currentThread();
		while(true){
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(t.getName());
		}
	}
}
public class JoinTest {
	public static void main(String[] args) {	
		Thread t1=new Thread(new MyThread03());
		t1.start();
		try {
			t1.join(5000); //main线程暂停5秒，5秒内t1执行，5秒后main线程恢复执行
		} catch (InterruptedException e1) {
			e1.printStackTrace();
		}
		Thread t=Thread.currentThread();
		while(true){
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(t.getName());
		}
	}
}
```



运行结果：

```txt
Thread-0
Thread-0
Thread-0
Thread-0
Thread-0
main
Thread-0
main
Thread-0
```



#### 线程中断

如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是给该线程发一个信号，该线程收到信号

后结束执行`run()`方法，使得该线程能立刻结束运行。

举个例子：假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，

这时，程序就需要中断下载线程的执行。中断一个线程只需要对目标线程调用`interrupt()`方法，目标线程需要

反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。

![1607499072739](D:/上课/网课/文档/JavaSE/image/637acc44-fbf9-4184-9573-f731c0edc366.png)

例如：

```java
class MyThread extends Thread {
    public void run() {
        int i = 0;
        while (!isInterrupted()) { //监测其是否被中断,被中断则退出循环,run()方法执行结束
            System.out.println("sub,"+i);
            i++;
        }
    }
}

public class InterruptTest {
	public static void main(String[] args){
        try {
			Thread t = new MyThread();
			t.start();
			System.out.println("main start");
			Thread.sleep(1); // 主线程暂停1毫秒，让子线程多执行一会儿
			t.interrupt(); // 中断t线程
			t.join(); // 等待t线程结束
			System.out.println("main end");
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
    }
}
```



运行结果：

```txt
main start
sub,0
sub,1
sub,2
sub,3
sub,4
sub,5
sub,6
sub,7
sub,8
sub,9
main end
```



另一个常用的中断线程的方法是设置标志位。我们通常会用一个`stop`标志位来标识线程是否应该停止运行，

在外部线程中，通过把`stop`置为`true`，就可以让线程结束：

例如：

```java
class MyThread04 implements Runnable{
	private volatile boolean stop=false;
	public void stopRunning(){
		stop=true;
	}
	public void run() {
		Thread t=Thread.currentThread();
		while(!stop){ //stop为true,退出循环,run()方法结束
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(t.getName());
		}
	}
}
public class StopTest {
	public static void main(String[] args) {
		MyThread04 r=new MyThread04();
		new Thread(r).start();//第1个线程启动
		new Thread(r).start();//第2个线程启动
		new Thread(r).start();//第3个线程启动
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		r.stopRunning();//3个线程全部停止
	}
}
```



运行结果：

```txt
Thread-0
Thread-2
Thread-1
Thread-0
Thread-2
Thread-1
```

注意到`MyThread04`的标志位`boolean stop`是一个线程间共享的变量。线程间共享变量需要使用`volatile`关

键字标记，确保每个线程都能立刻读取到更新后的变量值。

为什么要对线程间共享的变量用关键字`volatile`声明 ？这涉及到Java的内存模型。在Java虚拟机中，变量的值

保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了

变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！

![1607500536178](D:/上课/网课/文档/JavaSE/image/443e07f5-045d-4ae6-abff-a2c4654fc191.png)

这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。

例如，主内存的变量`a = true`，线程1执行`a = false`时，它在此刻仅仅是把变量`a`的副本变成了`false`，

主内存的变量`a`还是`true`，在JVM把修改后的`a`回写到主内存之前，其他线程读取到的`a`的值仍然`true`，

这就造成了多线程之间共享的变量不一致。因此，`volatile`关键字的目的是告诉虚拟机：

- 每次访问变量时，总是获取主内存的最新值；
- 每次修改变量后，立刻回写到主内存。

`volatile`关键字解决的是可见性问题：

当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。

如果去掉`volatile`关键字，运行上述程序，发现效果和带`volatile`差不多，这是因为在x86的架构下，

虚拟机回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。

#### 线程优先级

线程的优先级最低1，最高10：

NORM_PRIORITY : 值为 5

MAX_PRIORITY : 值为 10

MIN_PRIORITY : 值为 1

缺省优先级为 NORM_PRIORITY，也就是5，下面2个方法可以获取和设置线程的优先级

![1607504459292](D:/上课/网课/文档/JavaSE/image/d3a21b83-960e-4ccf-bb51-d72f0259e45c.png)

例如：

```java
class MyThread05 implements Runnable{
	public void run() {
		Thread t=Thread.currentThread();
		while(true){
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(t.getName());
		}
	}
}
public class PriorityTest {
	public static void main(String[] args) {
		Thread t1=new Thread(new MyThread05());
		Thread t2=new Thread(new MyThread05());
		t1.setPriority(Thread.MAX_PRIORITY); //最高优先级
		t2.setPriority(Thread.MIN_PRIORITY); //最低优先级
		t1.start();
		t2.start();
	}
}
```



CPU空闲情况下，2个线程执行的概率相当，只有在CPU高负载情况下，优先级高的线程比优先级低的线程有更大

的概率被执行。

#### 线程类型

线程分两类：

- 用户线程
- 守护线程(精灵线程)

守护线程与用户线程相对，前者的活动不会阻止Java进程的结束，而后者必须全部运行结束后Java进程才可以结

束。我们通过`setDaemon(boolean on)`来设置当前线程是否为守护线程。在守护线程中编写代码要注意：守护

线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，

这会导致数据丢失。

例如：

```java
class MyThread06 implements Runnable {
	public void run() {
		Thread t = Thread.currentThread();
		while(true){
			System.out.println(t.getName());
		}
	}
}

public class DaemonTest {

	public static void main(String[] args) {
		MyThread06 r = new MyThread06();
		Thread t=new Thread(r);
		t.setDaemon(true);//设置t为守护线程
		t.start();
	}
}
```



运行结果：

```txt
Thread-0
```



只打印很少几次线程名后程序就结束运行。

~~~java
class MyThread06 implements Runnable {
	public void run() {
		Thread t = Thread.currentThread();
		
		while(true){
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println("===========线程数量==========: "+t.getThreadGroup().activeCount());
		
		
			
		}
	}
}

class MyThread07 implements Runnable {

	@Override
	public void run() {


		Thread t = Thread.currentThread();
		
		for (int i = 0; i < 10; i++) {
			
			try {
				Thread.sleep((long) (Math.random()*1000));
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println(t.getName());
		}
		
	}
	
	
}
public class Test {

	public static void main(String[] args) {
		
		MyThread06 r = new MyThread06();
		Thread t=new Thread(r);
		t.setDaemon(true);//设置t为守护线程
		t.start();
		
		for (int i = 0; i < 20; i++) {
			MyThread07 r2 = new MyThread07();
			Thread t2=new Thread(r2);
			t2.start();
		}
		
		
		
	}
}
~~~



### 线程同步

#### 什么是线程同步

当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指

令处被操作系统暂停，然后在某个时间段后继续执行。此时如果多个线程同时访问同一份数据，很可能会出现数据

不一致的问题。在虚拟机中，堆和方法区是所有线程共享的，栈和寄存器是每个线程所独有的。

![1607590084578](D:/上课/网课/文档/JavaSE/image/e63019af-ddb3-4bce-be45-51c4d014e333.png)

![1607590741795](D:/上课/网课/文档/JavaSE/image/ce4ff452-c936-4b73-8634-fa100f8cef28.png)

堆中存放的是程序中创建的对象，栈中存放的是方法内部的局部变量。所以对方法内部的局部变量，不存在多个线

程共享的问题，因为每个线程都有自己的一份；而堆中对象的数据（成员变量），则可能同时被多个线程访问，

出现数据不一致的现象。

例如：

```java
class Station implements Runnable { //车站
	private int ticket = 100; //总共有100张票
	public void run() {
		while (true) {
			if (ticket > 0) {
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread().getName() + ":" + ticket--);
			}
		}
	}
}
public class SaleTicket {
	public static void main(String[] args) {
		Station s = new Station();
		// 模拟4个窗口同时卖100张票
		new Thread(s).start();
		new Thread(s).start();
		new Thread(s).start();
		new Thread(s).start();
	}
}
```



在执行结果的最后几行，可能会看到如下输出：

```txt
Thread-0:4
Thread-1:3
Thread-2:2
Thread-3:1
Thread-0:0
Thread-1:-1
Thread-2:-2
```



这里输出了不应该出现的数据：0、-1、-2，这种情况是如何发生的？来分析最后一张票（ticket = 1）的出售情况：

总共有4个子线程，此时，第1个线程获得CPU的时间片，执行`run()`方法中的代码：

```java
if (ticket > 0) 
```

条件满足，进入分支语句，紧接着执行

```java
Thread.sleep(10);
```

第1个线程进入阻塞状态，让出CPU的控制权；然后第2个线程获得CPU的时间片，执行`run()`方法中的代码，此

时因为`ticket`仍然等于1，所以第2个线程也会进入分支语句，然后阻塞；接下来第3个、第4个线程同样如此；

此时4个线程都进入了分支语句，并分别进入阻塞状态；阻塞结束的线程重新进入就绪状态，等待操作系统的调

度；阻塞结束后第1个获得CPU时间片的线程接着执行下面的代码：

```java
System.out.println(Thread.currentThread().getName() + ":" + ticket--);
```

在控制台输出1，然后自减成为0；然后第2个获得CPU时间片的线程执行同样的代码，输出0并自减为-1，第3个、

第4个线程同样如此，会分别输出-1、-2。

造成数据不一致的原因是因为有多个线程同时进入了售票指令组，可以同时对共享变量（ticket）进行修改；要保

证逻辑正确，对共享变量进行读写时，必须保证这组指令以原子方式执行，即某一个线程执行时，其他线程必须等

待，或者说同一时间只能有一个线程操作共享变量；通过加锁和解锁的操作，就能保证一组指令在一个线程执行期

间，不会有其他线程进入此指令区间。即使在执行时此线程被操作系统中断执行，其他线程也会因为无法获得锁而

导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行，这就是**线程同步**。

#### 线程同步的实现

##### synchronized

Java中可以使用`synchronized`关键字对一组指令进行加锁。synchronized是基于“监视器锁”这一概念实现，“监

视器锁”是用作互斥锁的对象。在给定时刻，只有一个线程可以拥有监视器锁。Java中所有的对象都拥有自己的监

视器锁。线程在获取 synchronized 锁失败(因为锁被其他线程占用)时会产生同步阻塞，此线程进入阻塞对象的锁

池等待锁的释放。

![1607671055237](D:/上课/网课/文档/JavaSE/image/a3913c23-1f27-4b6e-8a6b-4336ae14c0dd.png)

synchronized 的使用方式有2种，一种是同步代码块，另一种是同步方法。

同步代码块：

```java
class Station implements Runnable { //车站
	private int ticket = 100;//总共有100张票
	public static final Object lock = new Object();//锁对象
	public void run() {
		while (true) {
			synchronized (lock) {//同步代码块
				if (ticket > 0) {
					try {
						Thread.sleep(100);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					System.out.println(Thread.currentThread().getName() + ":" + ticket--);
				}
			}
		}
	}
}
```



同步方法：

```java
class Station implements Runnable { // 车站
	private int ticket = 100;// 总共有100张票
	public void run() {
		while (true) {
			saleTicket();
		}
	}
	public synchronized void saleTicket() {// 同步方法的锁对象:this
		if (ticket > 0) {
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(Thread.currentThread().getName() + ":" + ticket--);
		}
	}
}
```



此时，不会再输出0、-1、-2等无效数据

```txt
Thread-0:4
Thread-1:3
Thread-2:2
Thread-3:1
```



锁对象有以下几种情况：

- 同步代码块的锁对象是synchronized后小括号内传入的对象
- 同步成员方法的锁对象是this
- 同步静态方法的锁对象是此类的Class对象

##### Lock

`synchronzied`是托管给`jvm`执行的，是悲观锁； `JDK5`以后提供了一个新的锁对象`Lock`接口，Lock锁定

是通过`JAVA`代码实现的，是乐观锁。

![1607758816289](D:/上课/网课/文档/JavaSE/image/20ab0d0e-4f7e-478c-930b-4a3fb56edeaf.png)

例如：

```java
public class LockTest1 {
	private Lock lock = new ReentrantLock();//锁对象，使用完毕释放后其他线程才能获取锁
    public void lockTest(Thread thread) {
        lock.lock(); // 获取锁
        try {
            System.out.println(thread.getName() + "获取当前锁"); //打印当前锁的名称
            Thread.sleep(2000); //为看出执行效果，是线程此处休眠2秒
        } catch (InterruptedException e) {
            System.out.println(thread.getName() + "发生了异常释放锁");
        } finally {
            System.out.println(thread.getName() + "执行完毕释放锁");
            lock.unlock(); //释放锁
        }
    }

    public static void main(String[] args) {
        LockTest1 lockTest1 = new LockTest1();
        //线程一
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                lockTest1.lockTest(Thread.currentThread());
            }
        },"thread1");
        //线程二
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                lockTest1.lockTest(Thread.currentThread());
            }
        },"thread2");
        //启动2个线程
        thread1.start();
        thread2.start();
    }
}
```



运行结果:

```txt
thread1获取当前锁
thread1执行完毕释放锁
thread2获取当前锁
thread2执行完毕释放锁
```



![1607759203326](D:/上课/网课/文档/JavaSE/image/c2f6f561-0afb-48af-8f76-31c6beb35bec.png)

例如：

```java
public class LockTest3 {

    private Lock lock = new ReentrantLock();
    public void tryLockParamTest(Thread thread) throws InterruptedException {
        // 尝试获取锁 获取不到锁，就等3秒，如果3秒后还是获取不到就返回false
        if (lock.tryLock(3000, TimeUnit.MILLISECONDS)) {
            try {
                System.out.println(thread.getName() + "获取当前锁"); //打印当前锁的名称
                Thread.sleep(3800);//为看出执行效果，是线程此处休眠3.8秒
            } catch (Exception e) {
                System.out.println(thread.getName() + "发生了异常释放锁");
            }finally {
                System.out.println(thread.getName() + "执行完毕释放锁");
                lock.unlock(); //释放锁
            }
        }else{
            System.out.println(thread.getName()+"当前锁被占用,等待3s后仍无法获取,放弃!");
        }
    }

    public static void main(String[] args) {
        LockTest3 lockTest3 = new LockTest3();
        //线程1
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    lockTest3.tryLockParamTest(Thread.currentThread());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "thread1");
        //线程2
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    lockTest3.tryLockParamTest(Thread.currentThread());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "thread2");
        //启动2个线程
        thread1.start();
        thread2.start();
    }
}
```



执行结果：

```txt
thread2获取当前锁
thread1当前锁被占用,等待3s后仍无法获取,放弃!
thread2执行完毕释放锁
```



卖票的Lock版本:

```java
class TicketThread implements Runnable {
	private int ticket = 100;
	private Lock lock = new ReentrantLock();
	@Override
	public void run() {
		while (true) {
			sale();
		}
	}
	public void sale() {
		lock.lock();// 加锁
		try {
			if (ticket > 0) {
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread().getName() + ":" + ticket--);
			}
		} finally {
			lock.unlock();// 释放锁
		}
	}
}

public class TickSale {
	public static void main(String[] args) {
		TicketThread r = new TicketThread();
		new Thread(r).start();
		new Thread(r).start();
		new Thread(r).start();
		new Thread(r).start();
	}
}
```



#### 线程安全

线程安全是指通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据不一致的情况。

如果一个类被设计为允许多线程正确访问，这个类就是“线程安全”的（thread-safe）。

线程安全类的实现有几种情况：

1. 一个类的共享属性被设计成同一时间只能被一个线程操作。

   例如：

   ```java
    class Counter {
   	private int count = 0;//共享数据
   	public synchronized void add(int n) { //同步方法add
   		
   		
   		int num=count+n;
   				
   		try {
   			Thread.sleep(500);
   		} catch (InterruptedException e) {
   			// TODO Auto-generated catch block
   			e.printStackTrace();
   		}
   		
   		count = num;
   	
   		
   		
   	}
   	public synchronized void sub(int n) { //同步方法sub
   		
   		
   		
   		int num=count-n;
   		
   		try {
   			Thread.sleep(100);
   		} catch (InterruptedException e) {
   			// TODO Auto-generated catch block
   			e.printStackTrace();
   		}
   		
   		count = num;
   		
   	}
   	public int get() {
   		return count;
   	}
   }
   ```

   

   测试方法：

   ```java
   	public class Test{
   	
   	
   	
   	public static void main(String[] args) throws InterruptedException {
   		Counter c1 = new Counter();
   		// 对c1进行操作的线程:
   		Thread t1=new Thread(() -> {
   		    c1.add(10);
   		});
   		
   		
   		Thread t2=new Thread(() -> {
   			 c1.sub(10);
   		});
   		
   		
   		t1.start();
   		t2.start();
   		t1.join();
   		t2.join();
   		
   
   		
   		System.out.println(c1.get());
   	}
   	
   }
   ```

   

   此时，有2个线程访问同一个Counter的实例，假如第一个线程正在访问add方法，在add方法执行结束前，第

   2个线程不能访问sub方法；反之亦然；从而保证共享数据 count 是一致的。

   集合框架中的历史集合类，如`Vector`、`HashTable`；可变字符串中的`StringBuffer`是线程安全的；

   集合框架中的`ArrayList`、`HashMap`；可变字符串中的`StringBuilder`是线程不安全的 。

2. 一些不变类，例如`String`，`Integer`，`LocalDate`，它们的所有成员变量都是`final`，多线程同时访

   问时只能读不能写，这些不变类也是线程安全的。

3. 类似`Math`这些只提供静态方法，没有成员变量的类，也是线程安全的。

#### 死锁

Java的线程锁是可重入的锁。什么是可重入的锁？来看例子：

```java
class Counter {
    private int count = 0;
    public synchronized void add(int n) {
        if (n < 0) {
        	sub(-n);
        } else {
            count += n;
        }
    }
    public synchronized void sub(int n) {
        count += n;
    }
}
```



一旦线程执行到`add()`方法内部，说明它已经获取了当前实例的`this`锁。如果传入的`n < 0`，将在`add()`方

法内部调用`sub()`方法。由于`sub()`方法也需要获取`this`锁，现在问题来了：

对同一个线程，能否在获取到锁以后继续获取同一个锁？

答案是肯定的。JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。

一个线程可以获取一个锁后，再继续获取另一个锁。例如：

```java
class Counter{
	
    private int value;
	private int another;
	private final static Object lockA=new Object();
	private final static Object lockB=new Object();
	
	public void add(int m) {
		
	    synchronized(lockA) { // 获得lockA的锁
	        this.value += m;
	        try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
	        synchronized(lockB) { // 获得lockB的锁
	            this.another += m;
	        } // 释放lockB的锁
	    } // 释放lockA的锁
	}

	public void sub(int m) {
		
	    synchronized(lockB) { // 获得lockB的锁
	        this.another -= m;
	        try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
	        synchronized(lockA) { // 获得lockA的锁
	            this.value -= m;
	        } // 释放lockA的锁
	    } // 释放lockB的锁
	}
}
```

~~~java
public class Test{
	
	
	
	public static void main(String[] args) throws InterruptedException {
		Counter c1 = new Counter();
		// 对c1进行操作的线程:
		Thread t1=new Thread(() -> {
		    c1.add(10);
		});
		t1.start();
		
		Thread t2=new Thread(() -> {
			 c1.sub(10);
		});
		t2.start();
		
		
		
	}
	
}
~~~



对于上述代码，线程1和线程2如果分别执行`add()`和`sub()`方法时，可能导致死锁：

- 线程1：进入`add()`，获得`lockA`
- 线程2：进入`sub()`，获得`lockB`

随后：

- 线程1：准备获得`lockB`，失败，等待中
- 线程2：准备获得`lockA`，失败，等待中

此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。

死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。因此，在编写多线程应用时，要特别注意防止死

锁。因为死锁一旦形成，就只能强制结束进程。那么我们应该如何避免死锁呢？答案是：线程获取锁的顺序要一

致。即严格按照先获取`lockA`，再获取`lockB`的顺序，改写`sub()`方法如下：

```java
	public void sub(int m) {
	    synchronized(lockA) { // 获得lockA的锁
	        this.another -= m;
	        synchronized(lockB) { // 获得lockB的锁
	            this.value -= m;
	        } // 释放lockA的锁
	    } // 释放lockB的锁
	}
```



### 线程通信

#### wait()&notify()

JAVA提供了一个使用`wait()`、`notify()`、`notifyAll()`方法进行线程间通信的机制，这些方法是作为 

Object 类中的 final 方法实现的。

![1607760140613](D:/上课/网课/文档/JavaSE/image/94e49f61-c886-4503-85cc-17bb23354945.png)

注意：`notify()`、`wait()`必须用在同步的方法里。

![1607762318871](D:/上课/网课/文档/JavaSE/image/e9df453c-f945-42d4-8127-988eba81b51a.png)

生产者消费者:

```java
class WareHouse {
	
	public int count=0;
	
	public synchronized void put() {// 生产产品
		
		count++;
		System.out.println("生产后还有："+count);
		try {
			Thread.sleep(500);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		if (count>5) {// 商品超过5个等待
			try {
				wait();
			} catch (Exception e) {
			} // 进入等待池
		}
		
		notify();// 通知消费者可以消费
		
		
	}

	public synchronized void get() {// 消费产品
		
	
		if (count<=0) {// 判断当前是否有产品可以消费
			try {
				wait();
			} catch (Exception e) {
			} // 进入等待池
		}
		
		count--;
		System.out.println("消费后还有："+count);
		
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		notify();// 通知生产者可以生产
		
	}
}

//定义生产者线程
class Producter implements Runnable {
	private WareHouse wareHourse;

	public Producter(WareHouse wareHourse) {
		this.wareHourse = wareHourse;
	}

	public void run() {
	
		while (true) {// 不断生产
			
				wareHourse.put();
				
			
		}
	}
}

//定义消费者线程
class Customer implements Runnable {
	private WareHouse wareHourse;

	public Customer(WareHouse wareHourse) {
		this.wareHourse = wareHourse;
	}

	public void run() {
		while (true) {// 不断消费
			wareHourse.get();
			
		}
	}
}

public class Test {

	public static void main(String[] args) {
		WareHouse w = new WareHouse();
		Thread t1 = new Thread(new Producter(w));// 生产者线程
		Thread t2 = new Thread(new Customer(w));// 消费者线程
		t1.start();
		t2.start();
	}

}
```



执行结果：

```txt
生产后还有：1
生产后还有：2
生产后还有：3
生产后还有：4
生产后还有：5
生产后还有：6
消费后还有：5
消费后还有：4
消费后还有：3
生产后还有：4
生产后还有：5
消费后还有：4
消费后还有：3
消费后还有：2
消费后还有：1
消费后还有：0
生产后还有：1
```



#### Condition

`JDK5`以后提供了一个提供了`Condition`对象，`Condition`封装了`wait()`、`notify()`、`notifyAll()`

同步方法。

![1607760629008](D:/上课/网课/文档/JavaSE/image/09ae66a0-3cf5-4a56-b8b4-b23e2d6a25a0.png)

生产者消费者的Condition版本:

```java
class WareHouse {

	public int count = 0;

	private ReentrantLock lock = new ReentrantLock();
	private Condition condition = lock.newCondition();

	public void put() {// 生产产品

		try {
			lock.lock();

			count++;
			System.out.println("生产后还有：" + count);

			Thread.sleep(500);

			if (count > 5) {// 商品超过5个等待
				try {
					condition.await();
				} catch (Exception e) {
				} // 进入等待池
			}

			condition.signal();// 唤醒一个等待线程
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} finally {
			lock.unlock();
		}

	}

	public synchronized void get() {// 消费产品

		try {
			lock.lock();

			if (count <= 0) {// 判断当前是否有产品可以消费

				condition.await();
			}

			count--;
			System.out.println("消费后还有：" + count);
			
			Thread.sleep(1000);
			
			condition.signal();// 唤醒一个等待线程
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} finally {
			lock.unlock();
		}

	}
}

//定义生产者线程
class Producter implements Runnable {
	private WareHouse wareHourse;

	public Producter(WareHouse wareHourse) {
		this.wareHourse = wareHourse;
	}

	public void run() {

		while (true) {// 不断生产

			wareHourse.put();

		}
	}
}

//定义消费者线程
class Customer implements Runnable {
	private WareHouse wareHourse;

	public Customer(WareHouse wareHourse) {
		this.wareHourse = wareHourse;
	}

	public void run() {
		while (true) {// 不断消费
			wareHourse.get();

		}
	}
}

public class Test {

	public static void main(String[] args) {
		WareHouse w = new WareHouse();
		Thread t1 = new Thread(new Producter(w));// 生产者线程
		Thread t2 = new Thread(new Customer(w));// 消费者线程
		t1.start();
		t2.start();
	}

}
```



### 线程池

1. 使用线程池的原因：多线程运行时间，系统不断的启动和关闭新线程，成本非常高，会过渡消耗系统资源，

   以及过渡切换线程的危险，从而可能导致系统资源的崩溃。这时，线程池就是最好的选择了。

2. 线程池的概念：线程池就是预先在内存中创建好一些线程，它们的集合称为线程池。使用线程池可以很好地

   提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条

   线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行

   下一个任务。

3. 线程池的工作机制：在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程

   池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。

   一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。

4. 四种常用线程池

   第1种：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建

   线程；线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用

   每次新建线程。

   例如：

   ```java
   	public void type1(){
   		ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
   		cachedThreadPool.execute(new Runnable() {
   	        @Override
   	        public void run() {
   			    try {
   			    	Thread.sleep(100);
   			    } catch (InterruptedException e) {
   			        e.printStackTrace();
   			    }
   	            System.out.println("t1:"+Thread.currentThread().getName());
   	        }
   	    });
   	    try {
   	    	Thread.sleep(1000);
   	    } catch (InterruptedException e) {
   	        e.printStackTrace();
   	    }
   		cachedThreadPool.execute(new Runnable() {
   	        @Override
   	        public void run(){ 
   	            System.out.println("t2:"+Thread.currentThread().getName());
   	        }
   	    });
   		cachedThreadPool.shutdown();
   	}
   ```

   

   执行结果：

   ```txt
   t1:pool-1-thread-1
   t2:pool-1-thread-1
   ```

   

   第2种：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小最好

   根据系统资源进行设置。如：`Runtime.getRuntime().availableProcessors()`。

   例如：

   ```java
   	public void type2(){
   		ExecutorService fixedThreadPool = Executors.newFixedThreadPool(n);
   		for (int i = 0; i < 15; i++) {
   		    final int index = i;
   		    fixedThreadPool.execute(new Runnable() {
   		        @Override
   		        public void run() {
   		            try {
   		                System.out.println(index);
   		                Thread.sleep(2000);
   		            } catch (InterruptedException e) {
   		                // TODO Auto-generated catch block
   		                e.printStackTrace();
   		            }
   		        }
   		    });
   		}
   		fixedThreadPool.shutdown();
   	}
   ```

   

   因为线程池大小为n，每个任务输出index后sleep 2秒，所以每两秒打印n个数字。执行结果：

   ```txt
   0
   1
   3
   2
   4
   5
   7
   6
   8
   9
   10
   11
   12
   14
   13
   ```

   

   第3种：创建一个定长线程池，支持定时及周期性任务执行。

   ```java
   	public void type31(){
   		//创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下:
   		ScheduledExecutorService scheduledThreadPool 
   			= Executors.newScheduledThreadPool(5);
   		scheduledThreadPool.schedule(new Runnable() {
   		    @Override
   		    public void run() {
   		        System.out.println("delay 3 seconds");
   		    }
   		}, 3, TimeUnit.SECONDS);
             scheduledThreadPool.shutdown();
   	}
   ```

   

   3秒延迟后，执行1次，执行结果：

   ```txt
   delay 3 seconds
   ```

   

   ```java
   	public void type32(){
   		ScheduledExecutorService scheduledThreadPool 
   			= Executors.newScheduledThreadPool(5);
   		scheduledThreadPool.scheduleAtFixedRate(new Runnable() {
   			 @Override
   				public void run() {
   					System.out.println("delay 1 seconds, and excute every 3s");
   				}
   			}, 1, 3, TimeUnit.SECONDS);
   	}
   ```

   

   1秒延迟后，每隔3秒执行1次，执行结果：

   ```txt
   delay 1 seconds, and excute every 3s
   delay 1 seconds, and excute every 3s
   delay 1 seconds, and excute every 3s
   ```

   

   第4种：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序

   (FIFO, LIFO, 优先级)执行。

   ```java
   	public void type4(){
   		ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
   		for (int i = 0; i < 6; i++) {
   		    final int index = i;
   		    singleThreadExecutor.execute(new Runnable() {
   		        @Override
   		        public void run() {
   		            try {
   		                System.out.println(index+":"+
   		                		Thread.currentThread().getName());
   		                Thread.sleep(2000);
   		            } catch (InterruptedException e) {
   		                // TODO Auto-generated catch block
   		                e.printStackTrace();
   		            }
   		        }
   		    });
   		}
   		singleThreadExecutor.shutdown();
   	}
   ```

   

   执行结果：

   ```txt
   0:pool-1-thread-1
   1:pool-1-thread-1
   2:pool-1-thread-1
   3:pool-1-thread-1
   4:pool-1-thread-1
   5:pool-1-thread-1
   ```



### ThreadLocal

同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让

不同的线程排队访问，而后者为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个

变量，这样就避免了多个线程对数据的共享。

![1607860191393](D:/上课/网课/文档/JavaSE/image/a1a25c13-6c0f-472b-b75c-367cb6e29d59.png)

例如，对前面卖票的例子进行修改：

```java
class Station implements Runnable { // 车站
	private Integer ticket = 5;//每个线程的票数
	private static final ThreadLocal<Integer> local=new ThreadLocal<>();
	public void run() {
		while (true) {
			saleTicket();
		}
	}
	public void saleTicket() {
		Integer count=this.getTicket();
		if (count > 0) {
			try {
				Thread.sleep(1);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(Thread.currentThread().getName() + ":" + count--);
			local.set(count);
		}
	}
	public Integer getTicket() {
		if(local.get()==null) {
			local.set(ticket);//复制ticket的一个副本到当前线程中
		}
		return local.get();//从当前线程中获取数据
	}
}
public class SaleTicket {
	public static void main(String[] args) {
		Station s = new Station();
		// 模拟4个窗口同时卖票，此时是4个窗口各有5张票
		new Thread(s,"窗口1").start();
		new Thread(s,"窗口2").start();
		new Thread(s,"窗口3").start();
		new Thread(s,"窗口4").start();
	}
}
```



执行结果：

```txt
窗口3:5
窗口2:5
窗口1:5
窗口4:5
窗口3:4
窗口4:4
窗口1:4
窗口2:4
窗口3:3
窗口1:3
窗口4:3
窗口2:3
窗口3:2
窗口2:2
窗口1:2
窗口4:2
窗口2:1
窗口4:1
窗口1:1
窗口3:1
```



# 网络编程

## 什么是计算机网络

计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计

算机都需要遵循同一种网络协议。那什么是互联网呢？互联网是网络的网络（internet），即把很多计算机网络连

接起来，形成一个全球统一的互联网。对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机

网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。

因此，为了把计算机网络接入互联网，就必须使用TCP/IP协议。

TCP/IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP/IP协议的计算机才能够联

入互联网，使用其他网络协议是无法联入互联网的。

### IP地址

在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface），就好像家庭地址一样，用于对计算

机的定位。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址（对应多个网卡）。

IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似`101.202.99.12`，而IPv6采用128位地址，类似

`2001:0DA8:100A:0000:0000:1020:F2F3:1428`。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有

2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。

IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。

内网IP地址类似于：

- 192.168.x.x
- 10.x.x.x

有一个特殊的IP地址，称之为本机地址：`127.0.0.1`。

IPv4地址实际上是一个32位整数。例如：

```txt
106717964 = 0x65ca630c = 65  ca  63 0c = 101.202.99.12
```

如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址`127.0.0.1`，还有一个IP地址，例如

`101.202.99.12`，可以通过这个IP地址接入网络。

如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网

络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。

如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是

相同的。网络号是IP地址通过子网掩码过滤后得到的。例如：

某台计算机的IP是`101.202.99.2`，子网掩码是`255.255.255.0`，那么计算该计算机的网络号是：

```
IP = 101.202.99.2
Mask = 255.255.255.0
Network = IP & Mask = 101.202.99.0
```

每台计算机都需要正确配置IP地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相

同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同

一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网

关。网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。

所以，一台计算机的一个网卡会有3个关键配置：

- IP地址，例如：`172.20.254.115`
- 子网掩码，例如：`255.255.255.0`
- 网关的IP地址，例如：`172.20.254.1`

![1608174357668](D:/上课/网课/文档/JavaSE/image/5b50457f-ac77-4143-8e25-8928708c16ac.png)

### 域名

因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译

成对应的IP，客户端再根据IP地址访问服务器。

用`ping`可以查看域名对应的IP地址：

```
ping www.baidu.com

正在 Ping www.a.shifen.com [180.101.49.11] 具有 32 字节的数据:
来自 180.101.49.11 的回复: 字节=32 时间=6ms TTL=54
来自 180.101.49.11 的回复: 字节=32 时间=6ms TTL=54
来自 180.101.49.11 的回复: 字节=32 时间=6ms TTL=54
来自 180.101.49.11 的回复: 字节=32 时间=6ms TTL=54
```

有一个特殊的本机域名`localhost`，它对应的IP地址总是本机地址`127.0.0.1`。

### 网络模型

由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每

一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是ISO组织定义的一个计算机互联的标准

模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下

依次是：

- 应用层，提供应用程序之间的通信；
- 表示层：处理数据格式，加解密等等；
- 会话层：负责建立和维护会话；
- 传输层：负责提供端到端的可靠传输；
- 网络层：负责根据目标地址选择路由来传输数据；
- 链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。

互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：

| OSI    | TCP/IP     |
| ------ | ---------- |
| 应用层 | 应用层     |
| 表示层 |            |
| 会话层 |            |
| 传输层 | 传输层     |
| 网络层 | IP层       |
| 链路层 | 网络接口层 |
| 物理层 |            |

### 常用协议

IP协议是一个分组交换，它不保证可靠传输。而TCP协议是传输控制协议，它是面向连接的协议，支持可靠传输和

双向通信。TCP协议是建立在IP协议之上的，简单地说，IP协议只负责发数据包，不保证顺序和正确性，而TCP协

议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连

接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双

向通信，即通信双方可以同时发送和接收数据。TCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协

议之上的，例如HTTP、SMTP等。UDP协议（User Datagram Protocol）是一种数据报文协议，它是无连接协

议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP

协议要简单得多。选择UDP协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择

UDP协议。

### URL

URL是Uniform Resource Locator的缩写，译为“统一资源定位符”。可以唯一地标识一个资源在Internet上的位

置。通俗地说，URL是Internet上描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。采用

URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。

URL的一般格式为（带方括号[]的为可选项）：

```txt
protocol://hostname[:port]/path/[;parameters][?query]
```

URL的格式由三部分组成：

1. 第一部分是协议

2. 第二部分是存有该资源的主机IP地址，端口号为可选

3. 第三部分是主机资源的具体地址，如目录和文件名等，附加参数为可选



## 网络编程基础

在Java中，对应IP地址的类是`InetAddress`：

![1608176005743](D:/上课/网课/文档/JavaSE/image/90cee2cf-4563-438c-b0a3-ac59ae767434.png)

例如：

```java
		try {
			InetAddress[] ads=InetAddress.getAllByName("www.baidu.com");//获取百度的ip地址
			for(InetAddress address:ads){
				if(address.isReachable(10000)){ //测试是否可达
					System.out.println(address.getHostAddress());//输出IP
					System.out.println(address.getHostName());//输出域名
				}
			}
		} catch (UnknownHostException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
```



对应URL的类是同名类`URL`：

![1608178845760](D:/上课/网课/文档/JavaSE/image/c9e3a84e-9871-4700-80ce-605ee70a572a.png)

例如：

```java
		String urlPath="https://www.baidu.com";
		try {
			URL url=new URL(urlPath);
			System.out.println(url.getHost());//主机
			System.out.println(url.getProtocol());//协议
			System.out.println(url.getPort());//端口号
			System.out.println(url.getPath());//资源路径
			URLConnection conn=url.openConnection();
			conn.connect();//连接上
			HttpURLConnection hc=(HttpURLConnection)conn;
			InputStream in=hc.getInputStream();//获得响应内容
			InputStreamReader reader=new InputStreamReader(in,"utf-8");
			int data=reader.read();
			while(data!=-1){
				System.out.print((char)data);
				data=reader.read();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
```



## TCP编程

Socket编程模型：

![1608188395477](D:/上课/网课/文档/JavaSE/image/9d53ddfa-396c-4210-96bc-8e23e37ce69a.png)



Socket是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议把数据

传输到网络：

![1608188490907](D:/上课/网课/文档/JavaSE/image/4d1ae8c7-5f2d-43a9-8d18-2923efb6b0d7.png)

Socket、TCP和部分IP的功能都是由操作系统提供的，不同的编程语言只是提供了对操作系统调用的简单的封装。

例如，Java提供的几个Socket相关的类就封装了操作系统提供的接口。

`ServerSocket`：

构造：

![1608189070459](D:/上课/网课/文档/JavaSE/image/7d55f60a-2ee5-4aae-9803-617c26a4e261.png)

方法：

![1608188983735](D:/上课/网课/文档/JavaSE/image/124e5c44-8a2b-4dd5-a628-ea1f6efdf27d.png)

`Socket`：

构造：

![1608189159224](D:/上课/网课/文档/JavaSE/image/d2a74cc0-2cc6-4d82-87eb-a8f3ebe45e69.png)

方法：

![1608189219450](D:/上课/网课/文档/JavaSE/image/5a156f9b-64e3-4be6-94ca-c137238d3148.png)

为什么需要Socket进行网络通信？因为仅仅通过IP地址进行通信是不够的，同一台计算机同一时间会运行多个网络

应用程序，例如浏览器、QQ、邮件客户端等。当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判

断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数

据包才能根据Socket正确地发到对应的应用程序。

一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号

总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于保留端口，需要管理员权限，

大于1024的端口可以由任意用户的应用程序打开。

使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动

监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，

服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。

因此，当Socket连接成功地在服务器端和客户端之间建立后：

- 对服务器端来说，它的Socket是指定的IP地址和指定的端口号
- 对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号

接下来，结合多线程，使用Socket实现一个简单的聊天室程序：

服务器端代码：

```java
public class Server {
	public static void main(String[] args) {
		ServerSocket severSocket=null;
		try {
			severSocket=new ServerSocket(8888);
			List<Socket> list=new ArrayList<>();
			System.out.println("服务器启动,在8888端口等待客户连接中......");
			while(true){
				Socket socket=severSocket.accept();//在8888端口监听,等待连接
				list.add(socket);
				//启动新的线程负责与此客户的交互
				Thread t=new Thread(new ServerThread(socket,list));
				t.start();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```



服务器端负责聊天的子线程：

```java
//定义子线程对象,每个客户端连接成功以后,通过这个子线程负责与指定客户的交互
public class ServerThread implements Runnable{
	private Socket socket;//当前客户
	private List<Socket> list;//当前所有客户
	public ServerThread(Socket socket, List<Socket> list) {
		this.socket = socket;
		this.list = list;
	}
	@Override
	public void run() {
		DataInputStream serverIn=null;//服务器端输入流
		DataOutputStream serverOut=null;//服务器端输出流
		try {
			InputStream in=socket.getInputStream();
			OutputStream out=socket.getOutputStream();
			serverIn=new DataInputStream(in);
			serverOut=new DataOutputStream(out);
			serverOut.writeUTF("欢迎:"+socket.getRemoteSocketAddress());//提示欢迎信息
			String msg=null;
			do{	
				if(!socket.isClosed())
					msg=serverIn.readUTF();//读取当前客户的发言
				System.out.println(socket.getRemoteSocketAddress()+"说:"+msg);
				for(int i=0;i<list.size();i++){//将当前客户的发言发送给所有人
					Socket s=list.get(i);
					OutputStream o=s.getOutputStream();//服务器端的输出流
					DataOutputStream so=new DataOutputStream(o);
					if(!socket.isClosed())
						so.writeUTF(socket.getRemoteSocketAddress()+":"+msg);
				}
			}while(!"bye".equals(msg));
		} catch (IOException e) {
			System.out.println("socket已关闭");
		}finally{//释放资源
			list.remove(socket);//移除当前用户
			try {
				if(serverIn!=null) {
					serverIn.close();
				}
			} catch (IOException e) {
				e.printStackTrace();
			}finally {
				try {
					if(serverOut!=null) {
						serverOut.close();
					}
				} catch (IOException e) {
					e.printStackTrace();
				}finally {
					try {
						if(socket!=null) {
							socket.close();
						}
					} catch (IOException e) {
						e.printStackTrace();
					}
				}
			}
		}
	}
}
```



客户端代码:

```java
public class Client { 
	public static void main(String[] args) {
		DataOutputStream clientOut=null;
		Socket socket=null;
		Scanner sc=null;
		try {
			sc=new Scanner(System.in);
			socket=new Socket("127.0.0.1",8888);
			new Thread(new ClientThread(socket)).start();//启动子线程专门读取数据
			OutputStream out=socket.getOutputStream();//客户端的输出流
			clientOut=new DataOutputStream(out);
			String msg=null;
			do{
				msg=sc.nextLine();
				clientOut.writeUTF(msg);
			}while(!"bye".equals(msg));
		}catch (IOException e) {
			e.printStackTrace();
		}finally {
			try {
				if(clientOut!=null) {
					clientOut.close();
				}
			} catch (IOException e) {
				e.printStackTrace();
			}finally {
				try {
					if(socket!=null) {
						socket.close();
					}
				} catch (IOException e) {
					e.printStackTrace();
				}finally {
					if(sc!=null) {
						sc.close();
					}
				}
			}
		}
	}
}
```



客户端负责读取聊天信息的子线程：

```java
//负责在客户端读取数据
public class ClientThread implements Runnable{
	private Socket socket;
	public ClientThread(Socket socket) {
		this.socket = socket;
	}
	public void run() {
		DataInputStream clientIn=null;
		try {
			InputStream in=socket.getInputStream();//客户端的输入流
			clientIn=new DataInputStream(in);
			while(!socket.isClosed()){
				String str=clientIn.readUTF();//读取服务器端的输出
				System.out.println(str);
			}
			clientIn.close();
		} catch (IOException e) {
			System.out.println("socket已关闭");
		}finally {
			try {
				if(clientIn!=null) {
					clientIn.close();
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}
```



## UDP编程

和TCP编程相比，UDP编程就简单得多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有流的概念。

例如，消息接受方：

```java
public class UdpRecv {
	//先启动这个类，等待接受信息。
	public static void main(String[] args){
		System.out.println("等待接受");
		DatagramSocket datagramSocket = null;
		try {
			datagramSocket = new DatagramSocket(8080);// 指定接受信息的端口
			byte[] buf = new byte[1024];// 指定最大接受信息的大小
			DatagramPacket datagramPacket = new DatagramPacket(buf, 1024);
			datagramSocket.receive(datagramPacket);// 阻塞等待
			String string 
					= new String(datagramPacket.getData(), 0, datagramPacket.getLength()) 
					+ "  from  "
					+ datagramPacket.getAddress().getHostAddress() 
					+ ":" + datagramPacket.getPort();
			System.out.println(string);
		} catch (SocketException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}finally {
			if(datagramSocket!=null) {
				datagramSocket.close();
			}
		}
	}
}
```



消息发送方：

```java
public class UdpSend {
	//后启动发送类，发送消息。
	public static void main(String[] args){
		System.out.println("发送:");
		DatagramSocket datagramSocket = null;
		try {
			datagramSocket = new DatagramSocket();
			String str = "一天之计在于晨";
			DatagramPacket datagramPacket = new DatagramPacket(
					str.getBytes(), str.getBytes().length,
					InetAddress.getByName("127.0.0.1"), 8080);
			datagramSocket.send(datagramPacket);
		} catch (SocketException e) {
			e.printStackTrace();
		} catch (UnknownHostException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}finally {
			if(datagramSocket!=null)
				datagramSocket.close();
		}
	}
}
```



# 反射

## Class类

### Class类简介

在JAVA的世界中，万物皆为对象。各个类的类型也是对象，即Class对象。它包含了与类有关的信息：类中有哪些

属性，有哪些构造函数，有哪些方法等等。Java中使用Class对象执行其RTTI（Run-Time Type Identification：运

行时类型识别），多态就是基于RTTI实现的。每一个类都有一个Class对象，每当编译一个新类时就产生一个Class

对象，基本类型 (boolean、 byte、 char、 short、int、long、float、 double)有Class对象，数组有Class对象，

就连关键字void也有Class对象（void.class）。Class对象对应着`java.lang.Class`类，如果说类是对象的抽象，

那么Class类就是对类的类型的抽象。Class类没有公共的构造方法，Class对象是在类加载的时候由Java虚拟机通

过调用类加载器中的 `defineClass` 方法自动构造的，因此不能显式地声明一个Class对象。一个类被加载到内存

需要经历如下三个阶段：

1. 加载，这是由类加载器（`ClassLoader`）执行的。通过一个类的完全限定名（完整的包名+类名）来获取其

   定义的二进制字节流（Class字节码），根据字节码在堆中生成一个代表这个类的`java.lang.Class`对象。

2. 链接。在链接阶段将验证Class文件中的字节流包含的信息是否符合当前虚拟机的要求，为静态域分配存储空

   间并设置类变量的初始值，将常量池中的符号引用转化为直接引用（地址）。

3. 初始化。初始化阶段是执行类构造器`clinit()`方法的过程。类构造器`clinit()`方法是由编译器自动收

   集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。

   - 当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。

   - 虚拟机会保证一个类的`clinit()`方法在多线程环境中被正确加锁和同步。

所有的类都是在对其第一次使用时，动态加载到JVM中的（懒加载）。因此java程序程序在它开始运行之前并非被

完全加载，其各个类都是在使用时才加载的。在类加载阶段，类加载器首先检查这个类的Class对象是否已经被加

载。如果尚未加载，默认的类加载器就会根据类的全限定名查找.class文件。在这个类的字节码被加载时，它们会

接受验证，以确保其没有被破坏，并且不包含不良java代码。一旦某个类的Class对象被载入内存，就可以用它来

创建这个类的对象。

### 获取Class类

1. 直接通过静态属性`class`获取：

   ```java
   Class cls = String.class;
   ```

   

2. 通过对象的`getClass()`方法获取：

   ```java
   String s = "Hello";
   Class cls = s.getClass();
   ```

   

3. 通过静态方法`Class.forName(类的完全限定名)`获取：

   ```java
   Class cls = Class.forName("java.lang.String");
   ```

   

因为`Class`实例在JVM中是唯一的，所以，上述方法获取的`Class`实例是同一个实例。

```java
Class cls1 = String.class;
String s = "Hello";
Class cls2 = s.getClass();
System.out.println(cls1 == cls2); // true
```



## 字段

### 获得字段信息

Class类中的方法：

![1608386221811](D:/上课/网课/文档/JavaSE/image/b9d76113-2913-45ff-b312-fdffa185edde.png)

其中：

- `getField(name)`：根据字段名获取某个public的field（包括父类）
- `getDeclaredField(name)`：根据字段名获取当前类的某个field（不包括父类）
- `getFields()`：获取所有public的field（包括父类）
- `getDeclaredFields()`：获取当前类的所有field（不包括父类）

对应属性的类为`java.lang.reflect.Field`，其定义有如下方法：

![1608387963073](D:/上课/网课/文档/JavaSE/image/ecb75f22-9549-4f0e-a223-6d66f7d1db1c.png)

其中，`getModifiers()`：返回字段的修饰符，它是一个`int`，不同的bit表示不同的含义。

例如：

 ```java
public class FieldInfo {
	public static void main(String[] args) throws Exception {
		Class<?> stdClass = Student.class;
		Field[] fs = stdClass.getDeclaredFields();//获得Student中定义的所有属性
		for (int i = 0; i < fs.length; i++) {
			Field f = fs[i];
			System.out.print("属性名:"+f.getName()+"\t");
			System.out.print("属性类型:"+f.getType()+"\t");
			System.out.println("属性的访问修饰符:"+Modifier.toString(f.getModifiers()));
		}
		System.out.println(stdClass.getField("name"));//获取名为name的public的field（含父类）
	}
}

class Student extends Person {
	public int score;
	private int grade;
}

class Person {
	public String name;
}

 ```



输出：

```txt
属性名:score	属性类型:int	属性的访问修饰符:public
属性名:grade	属性类型:int	属性的访问修饰符:private
public java.lang.String com.study.reflect.Person.name
```



### 访问字段

通过Field可以获取到指定实例的字段值，也可以设置字段的值。

![1608438190905](D:/上课/网课/文档/JavaSE/image/606cd07c-09d8-4c50-86de-01fa58f89097.png)

如需设置`private`字段，需要首先调用`setAccessible(true)`将其设置成可以修改。System.setSecurityManager(new SecurityManager()); 则不成功。

例如：

```java
public class FieldOperate {
	public static void main(String[] args) throws Exception {
		Student stu = new Student();
		Class<?> stdClass = stu.getClass();
		Field nameField = stdClass.getDeclaredField("name");//获得name属性
		System.out.println("Origin: "+nameField.get(stu));//打印name属性的值
		nameField.set(stu, "里斯");//重新设置name属性
		System.out.println("New: "+nameField.get(stu));	
		Field ageField = stdClass.getDeclaredField("age");//获得age属性
		ageField.setAccessible(true);//对private修饰的属性需要设置成可以访问
		System.out.println("Origin: "+ageField.get(stu));//打印age属性的值
		ageField.set(stu, 21);//重新设置age属性
		System.out.println("New: "+ageField.get(stu));
	}
}

class Student {
	public String name;
	private int age;
	public Student() {
		name = "张三";
		age = 20;
	}
}
```



执行结果：

```txt
Origin: 张三
New: 里斯
Origin: 20
New: 21
```



## 方法

### 获得方法信息

Class类中的方法：

![1608441201934](D:/上课/网课/文档/JavaSE/image/d88b80d9-0d90-41c8-874a-9302fb1c6d48.png)

其中：

- `getMethod(name, Class...)`：获取某个`public`的`Method`（包括父类）
- `getDeclaredMethod(name, Class...)`：获取当前类的某个`Method`（不包括父类）
- `getMethods()`：获取所有`public`的`Method`（包括父类）
- `getDeclaredMethods()`：获取当前类的所有`Method`（不包括父类）

对应方法的类是`java.lang.reflect.Method`，其定义有如下方法：

![1608441579497](D:/上课/网课/文档/JavaSE/image/054cb5fa-7a10-4702-8430-81b58069b934.png)

例如：

```java
public class MethodInfo {

	public static void main(String[] args) {
		try {
			Class<?> cls=Class.forName("com.study.info.Sub");
			Method[] ms=cls.getDeclaredMethods();//获得Sub中所有Method（不包括父类）
			for(int i=0;i<ms.length;i++){
				Method m=ms[i];
				System.out.print("方法名:"+m.getName()+"\t");
				System.out.print("返回类型:"+m.getReturnType()+"\t");
				System.out.println("访问修饰符:"+Modifier.toString(m.getModifiers()));
				System.out.print("参数类型：");
				Class<?>[] types=m.getParameterTypes();//获得方法的参数类型数组
				if(types.length>0){
					for(Class<?> c:types){
						System.out.print(c+"\t");
					}
				}else {
					System.out.print("无参");
				}
				System.out.println();
			}
			//获取名为getName的public的Method（包括父类）
			Method m=cls.getMethod("getName", new Class[]{String.class});
			System.out.println(m);
					
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

class Sub extends Base {
	public int getScore(Integer origin,int add) {
		return origin+add;
	}
	private int getGrade() {
		return 1;
	}
}

class Base {
	public String getName(String old) {
		return old.toUpperCase();
	};
}
```



执行结果：

```txt
方法名:getScore	返回类型:int	访问修饰符:public
参数类型：class java.lang.Integer	int	
方法名:getGrade	返回类型:int	访问修饰符:private
参数类型：无参
public java.lang.String com.study.info.Base.getName(java.lang.String)
```



### 调用方法

通过Method中的`invoke`方法可以执行此方法：

![1608442455886](D:/上课/网课/文档/JavaSE/image/d6f7e5e9-31f3-43aa-a50a-b112274ae388.png)

如需访问`private`方法，需要首先调用`setAccessible(true)`将其设置成可以调用。为了保证JVM核心库的安

全，如果JVM运行期存在`SecurityManager`，可能不允许对`java`和`javax`开头的`package`的类调用

`setAccessible(true)`，会导致`setAccessible(true)`失败。

例如：

```java
public class MethodOperate {
	public static void main(String[] args) {
		try {
			Employee employee=new Employee();
			Class<?> cls=employee.getClass();
			//获得名为getName的方法
			Method m1=cls.getDeclaredMethod("getName", new Class[]{String.class});
			//传入实参调用getName方法
			String newName=(String)m1.invoke(employee, new Object[] {"tom"});
			System.out.println("getName方法执行的结果是:"+newName);
			//获得名为getAge的方法
			Method m2=cls.getDeclaredMethod("getAge", new Class[]{});
			m2.setAccessible(true);//private方法设置其可访问
			//调用getAge方法
			Integer age=(Integer)m2.invoke(employee, new Object[] {});
			System.out.println("getAge方法执行的结果是:"+age);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

class Employee {
    public String getName(String old) {
		return old.toUpperCase();
	};
    private Integer getAge() {
		return 20;
	};
}
```



执行结果：

```txt
getName方法执行的结果是:TOM
getAge方法执行的结果是:20
```



如果获取到的Method是一个静态方法，因为调用静态方法时无需实例对象，所以`invoke`方法传入的第一个参数

为`null`。

例如：

```java
public class StaticMethodOperate {
	public static void main(String[] args) {
		try {
			//获取Integer.parseInt(String)方法
			Method m = Integer.class.getMethod("parseInt", String.class);
			//调用该静态方法
			Integer n = (Integer) m.invoke(null, "100");
			System.out.println(n);//100
		}  catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```



## 构造

### 获得构造信息

Class类中的方法：

![1608450751308](D:/上课/网课/文档/JavaSE/image/9f3c4a5d-9380-47b4-b54d-845d78c2cef2.png)

其中：

- `getConstructor(Class...)`：获取某个`public`的`Constructor`
- `getDeclaredConstructor(Class...)`：获取某个`Constructor`
- `getConstructors()`：获取所有`public`的`Constructor`
- `getDeclaredConstructors()`：获取所有`Constructor`

对应构造函数的类是`java.lang.reflect.Constructor`，其定义有如下方法：

![1608451089334](D:/上课/网课/文档/JavaSE/image/e9dfd9a6-5aff-4881-8974-646539e07659.png)

例如：

```java
public class ConstructorInfo {
	public static void main(String[] args) {
		try {
			Class<?> cls=Class.forName("com.study.info.Account");
			Constructor<?>[] cs=cls.getDeclaredConstructors();//获得Account中所有构造函数
			for(int i=0;i<cs.length;i++){
				Constructor<?> m=cs[i];
				System.out.print("方法名:"+m.getName()+"\t");
				System.out.println("访问修饰符:"+Modifier.toString(m.getModifiers()));
				System.out.print("参数类型：");
				Class<?>[] types=m.getParameterTypes();//获得构造函数的参数类型数组
				if(types.length>0){
					for(Class<?> c:types){
						System.out.print(c+"\t");
					}
				}else {
					System.out.print("无参");
				}
				System.out.println();
			}
			//获取参数为2个字符串的public构造函数
			Constructor<?> c=cls.getConstructor(String.class,String.class);
			System.out.println(c);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

class Account{
	private String cardNo;
	private String password;
	public Account() {
		super();
	}
	private Account(String cardNo) {
		super();
		this.cardNo = cardNo;
	}
	public Account(String cardNo, String password) {
		super();
		this.cardNo = cardNo;
		this.password = password;
	}
}
```



执行结果：

```txt
方法名:com.study.info.Account	访问修饰符:public
参数类型：无参
方法名:com.study.info.Account	访问修饰符:private
参数类型：class java.lang.String	
方法名:com.study.info.Account	访问修饰符:public
参数类型：class java.lang.String	class java.lang.String	
public com.study.info.Account(java.lang.String,java.lang.String)
```



### 调用构造

通过Constructor类的`newInstance(参数列表)`方法可以创建类的实例。

![1608451898399](D:/上课/网课/文档/JavaSE/image/2254d101-5ec1-43c3-b8f0-f930d321ce44.png)

如需访问`private`的构造，需要首先调用`setAccessible(true)`将其设置成可以调用，与方法类似，

`setAccessible(true)`也可能失败。

例如：

```java
public class ConstructorOperate {
	public static void main(String[] args) {
		try {
			Class<?> cls=Class.forName("com.study.operate.Account");
			//获取参数为2个字符串的构造函数
			Constructor<?> c1=cls.getDeclaredConstructor(String.class,String.class);
			//创建对象
			Account a1=(Account)c1.newInstance(new Object[] {"C001","123456"});
			System.out.println(a1);
			//获取参数为1个字符串的构造函数
			Constructor<?> c2=cls.getDeclaredConstructor(String.class);
			c2.setAccessible(true);//private构造设置其可访问
			//创建对象
			Account a2=(Account)c2.newInstance(new Object[] {"C002"});
			System.out.println(a2);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

class Account{
	private String cardNo;
	private String password;
	public Account() {
		super();
	}
	private Account(String cardNo) {
		super();
		this.cardNo = cardNo;
		this.password = "123";
	}
	public Account(String cardNo, String password) {
		super();
		this.cardNo = cardNo;
		this.password = password;
	}
	@Override
	public String toString() {
		return "Account [cardNo=" + cardNo + ", password=" + password + "]";
	}
}
```



执行结果：

```txt
Account [cardNo=C001, password=123456]
Account [cardNo=C002, password=123]
```



# 注解

## 注解简介

Annontation是Java5开始引入的新特征，中文名称叫注解。它提供了一种类似注释的机制，用来将任何的信息或

元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加

上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像

一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。

Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。

注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。

注解的用处：

1. 生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等

2. 跟踪代码依赖性，运行时动态处理，获取信息，实现替代配置文件功能。比如Spring依赖注入，实际开发过

   程中将大量使用注解配置。

3. 在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检

   查出。

JDK提供了一些常用的注解：

- @Override，代表某方法是重写父类中的方法
- @Deprecated，表示被标记的内容已经过时、不建议使用，如果使用编译器会警告，但程序还能正常运行
- @SuppressWarnings("all")，由于内容被@Deprecated标记后，编译器会有警告，如果想忽略警告可以使用



## 元注解

java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：

- @Documented – 注解是否将包含在JavaDoc中
- @Retention – 什么时候使用该注解
- @Target – 注解用于什么地方
- @Inherited – 是否允许子类继承该注解

### @Retention

@Retention定义注解的生命周期：

1. RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入

   字节码。@Override, @SuppressWarnings都属于这类注解。

2. RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式。

3. RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。

   我们自定义的注解通常使用这种方式。

### @Target

@Target表示该注解用于什么地方：

1. ElementType.CONSTRUCTOR: 用于描述构造器
2. ElementType.FIELD: 成员变量、对象、属性（包括enum实例）
3. ElementType.LOCAL_VARIABLE: 用于描述局部变量
4. ElementType.METHOD: 用于描述方法
5. ElementType.PACKAGE: 用于描述包
6. ElementType.PARAMETER: 用于描述参数
7. ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明

### @Documented

@Documented表示是否将注解信息添加在java 文档中。

### @Inherited

@Inherited 定义该注释和子类的关系

@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 

修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。

例如：

```java
@Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到
@Target({ElementType.FIELD,ElementType.METHOD})//定义注解的作用范围包括字段、枚举的常量/方法
@Documented//说明该注解将被包含在javadoc中
@Inherited //这个注解将被用于该class的子类
```

## 自定义注解

如何定义一个注解呢？可以先看看这些已有的注解是如何实现的，先以@Override为例：

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
```

可以看到注解是通过@interface关键字来定义的，和接口的定义类似，再看看@SuppressWarnings注解的实现：

```java
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
```

和@Override相比最大的区别就是注解体中多了String[] value();，它代表注解的属性。

一个自定义注解的伪代码如下：

```java
@元注解0
@元注解1
@元注解2
public @interface 注解名称 {
    类型 attr0();
    类型 attr1();
}
```

自定义注解类编写的一些规则:

1. Annotation 类型定义为@interface, 所有的Annotation 会自动继承java.lang.Annotation这一接口,并且不能

   再去继承别的类或是接口.

2. 参数成员只能用public 或默认(default) 这两个访问修饰符

3. 参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和

   String、Enum、Class、annotations等数据类型，以及这一些类型的数组

例如：

```java
@Target(value = {ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface SelfAnnotation {
    String name();
    int age() default 18;
    String[] favour();
}
```



SelfAnnotation注解中定义了name、age两个属性，并用default关键字指定age的默认值为18。

注解的使用：

```java
@SelfAnnotation(name = "Test", age = 20, favour = {"music", "sports"})
public class UseAnnotation {

    @SelfAnnotation(name = "testField", favour = {"reading", "sports"})
    private int testField;

    @SelfAnnotation(name = "testMethod", age = 10, favour = {"dancing", "music"})
    public void testMethod() {

    }

    @SelfAnnotation(name = "testMethod1", age = 12, favour = {"music"})
    public void testMethod1() {

    }
}
```



由于age有默认值，可以在使用注解时不指定它的值。由于favour的类型为数组，所以当其有多个值时需要用{}包

起来。如果自定义注解没有属性或者属性有默认值，则使用时可以直接写@TestAnnotation，省略后边的括号。

## 注解信息读取

要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象

例如：

```java
public class GetAnnotationInfo {
	public static void main(String[] args) {
		// 解析类上的注解
        boolean isPresent = 	
            UseAnnotation.class.isAnnotationPresent(SelfAnnotation.class);
        if (isPresent) {
            SelfAnnotation annotation = 
            		UseAnnotation.class.getAnnotation(SelfAnnotation.class);
            System.out.println("类的注解信息：");
            showAnnotation(annotation);
        }
        // 解析字段上的注解
        Field[] fields = UseAnnotation.class.getDeclaredFields();
        System.out.println("属性的注解信息：");
        for (Field field : fields) {
            if (field.isAnnotationPresent(SelfAnnotation.class)) {
                SelfAnnotation annotation = field.getAnnotation(SelfAnnotation.class);
                showAnnotation(annotation);
            }
        }
        // 解析方法上的注解
        Method[] methods = UseAnnotation.class.getDeclaredMethods();
        System.out.println("方法的注解信息：");
        for (Method method : methods) {
            if (method.isAnnotationPresent(SelfAnnotation.class)) {
                SelfAnnotation annotation = method.getAnnotation(SelfAnnotation.class);
                showAnnotation(annotation);
            }
        }
	}
	private static void showAnnotation(SelfAnnotation annotation) {
        System.out.println("Annotation:"+annotation.name() + ";" + annotation.age() + ";" 
        		+ Arrays.toString(annotation.favour()));
    }
}
```



执行结果：

```txt
类的注解：
Annotation:Test;20;[music, sports]
属性的注解：
Annotation:testField;18;[reading, sports]
方法的注解：
Annotation:testMethod1;12;[music]
Annotation:testMethod;10;[dancing, music]
```



代码中使用到了几个常用方法，Class、Method、Field等类都有这样的方法：

- `boolean isAnnotationPresent(Class<? extends Annotation> annotation)`

  用来判断是否使用了某个注解

- `public <A extends Annotation> A getAnnotation(Class<A> annotation)`

  获得指定名称的注解对象

- `public Annotation[] getAnnotations()`

  返回对应元素的全部注解

- `public Annotation[] getDeclaredAnnotations()`

  返回直接在对应元素上使用的注解，不包括父类的注解

- `boolean isAnnotationPresent(Class<? extends Annotation> annotation)`

  用来判断是否使用了某个注解

- `public <A extends Annotation> A getAnnotation(Class<A> annotation)`

  获得指定名称的注解对象

- `public Annotation[] getAnnotations()`

  返回对应元素的全部注解

- `public Annotation[] getDeclaredAnnotations()`

  返回直接在对应元素上使用的注解，不包括父类的注解