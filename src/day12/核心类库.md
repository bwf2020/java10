# JavaSE核心类库

## 异常处理

### 为什么要进行异常处理

现在存在的问题:

```java
public static void main(String[] args) {
		Scanner sc=null;
    	sc=new Scanner(System.in);
		System.out.print("输入1个数：");
		String s=sc.nextLine();
		int num=Integer.parseInt(s);
		System.out.println(num);
		sc.close();
}
```

假如在程序第5行执行时输入一个字符串"s"，程序直接崩溃，终止执行

![1605161720497](image/240fef37-3e38-4e92-93e0-3ca93b014f7a.png)

异常处理的意义，就是在程序出错以后仍然能够继续运行下去.

### Java中异常的体系结构

![1605073008221](image/7e90c75a-4ae0-44d7-a608-9f658ec692da.png)



###  java中与异常处理相关的5个关键字

- try：try代码块中放可能产生异常的代码
- catch：catch代码块中放处理异常的代码
- finally：finally代码块中放一定会被执行的代码
- throw：throw用在代码中手工抛出异常
- throws：throws用在方法的声明部分，表示此方法会抛出异常

###  try&catch

try后面跟一个代码块，将可能产生异常的代码放在这个代码块里

catch后放处理异常的代码，catch后的小括号中必须定义一个异常类型的引用，用来接收try块抛出的异常对象。

try代码块产生异常时，异常信息会被封装到某个类型的异常对象中，

该对象被传递给catch后面小括号中定义的异常类型的引用

语法：

```java
		try {
			//可能产生异常的代码
		}catch(Exception ex) {
			//异常处理的代码
		}
```

例如：

```java
	public static void main(String[] args) {
		Scanner sc=null;
    	sc=new Scanner(System.in);
		System.out.print("输入1个数：");
		String s=sc.nextLine();
		try {
			int num=Integer.parseInt(s);//可能产生异常
			System.out.println(num);
		} catch (NumberFormatException e) {
			System.out.println("处理异常的代码");
		}
		System.out.println("try,catch后的代码");
		sc.close();
	}
```



try,catch的3种情况：

第1种：try块没有产生异常，try块里的代码执行完毕，不会进catch, 接着执行try,catch后面的其它代码

测试过程：

```java
输入1个数：666
用户输入的是:666
try,catch后的代码
```



第2种：try块产生异常，并且产生的异常被正确的捕获到了，直接从产生异常的代码进入catch，产生异常的代码

后的其它代码不会执行，catch块里的代码执行完毕后，接着执行try,catch后面的代码

测试过程：

```java
输入1个数：a
处理异常的代码
try,catch后的代码
```



第3种：try块产生异常，并且产生的异常没有被正确的捕获到了，程序执行直接中断，

和没有对异常进行处理是一样的

例如：

```java
	public static void main(String[] args) {
		Scanner sc=null;
    	sc=new Scanner(System.in);
		System.out.print("输入1个数：");
		String s=sc.nextLine();
		try {
			int num=Integer.parseInt(s);//可能产生异常
			System.out.println("用户输入的是:"+num);
		} catch (NullPointerException e) {
			System.out.println("处理异常的代码");
		}
		System.out.println("try,catch后的代码");
		sc.close();
	}
```



测试过程：

```java
输入1个数：a
Exception in thread "main" java.lang.NumberFormatException: For input string: "a"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at com.study.Demo01.main(Demo01.java:12)
```



假如try代码块里的代码可能产生多种异常，此时1个try对应多个catch

执行过程：

try块产生异常后，将产生的异常跟第1个catch里的异常类型进行比较，

假如异常类型匹配，进入这个catch代码块，catch代码块执行完毕，忽略其它的catch块，接下去执行try,catch块

后的其它代码；假如不匹配，与下一个catch进行比较，直到找到匹配的，则进入匹配的catch块，catch代码块执

行完毕，忽略其它的catch块，假如都不匹配，程序中断，相当于没有对异常进行处理。

当要捕获的多个异常存在父子关系的时候，子类在前，父类在后，否则会产生不可达的代码，编译报错；

假如不存在父子关系，无所谓先后。

```java
	public static void main(String[] args) {
		Scanner sc=null;
		try{
			sc=new Scanner(System.in);
			System.out.print("输入第1个数：");
			String s1=sc.nextLine();
			int num1=Integer.parseInt(s1);
			System.out.print("输入第2个数：");
			String s2=sc.nextLine();
			int num2=Integer.parseInt(s2);
			System.out.println("运行结果是:"+num1/num2);
		}catch(NumberFormatException ex){
            //多个catch:
            //1.catch的多个异常类型无父子关系,对先后无要求  												//2.catch的多个异常类型有父子关系,先子后父
			//假如catch小括号中的异常类型能够指向try代码块中抛出的异常对象,则能捕获异常
			//RuntimeException ex=new ArithmeticException();
			//RuntimeException ex=new NumberFormatException();
			System.out.println("出错了");
			ex.printStackTrace();
		}catch(RuntimeException ex){
			ex.printStackTrace();
		}
		System.out.println("异常处理后的代码");
		sc.close();
	}
```



###  finally

finally代码块中放一定会执行的代码，无论前面的try…catch是3种情况下的哪一种，finally块一定会被执行到，

finally代码块中通常写释放资源的代码。

语法:

```java
try{
	//可能产生异常的代码
}catch(Exception ex){
   //处理异常的代码
}finally{
   //一定会被执行的代码
}
```

例如:

```java
	public static void main(String[] args) {
		Scanner sc=null;
		try{
			sc=new Scanner(System.in);
			System.out.print("输入第1个数：");
			String s1=sc.nextLine();
			int num1=Integer.parseInt(s1);
			System.out.print("输入第2个数：");
			String s2=sc.nextLine();
			int num2=Integer.parseInt(s2);
			System.out.println(num1/num2);
		}catch(NumberFormatException ex){
			ex.printStackTrace();
		}finally{
			System.out.println("一定会执行的代码");
		}
		System.out.println("异常处理后的代码");
		sc.close();
	}
```



try后面可以只跟catch(可以有多个), 也可以只跟finally(1个),也可以二者都有

例如：

```java
	public static void main(String[] args) {
		Scanner sc=null;
		try{
			sc=new Scanner(System.in);
			System.out.print("输入第1个数：");
			String s1=sc.nextLine();
			int num1=Integer.parseInt(s1);
			System.out.print("输入第2个数：");
			String s2=sc.nextLine();
			int num2=Integer.parseInt(s2);
			System.out.println(num1/num2);
		}finally{
			System.out.println("一定会执行的代码");
		}
		System.out.println("异常处理后的代码");
		sc.close();
	}
```



> 想一想、试一试:

以下2段代码输出结果时什么?

```java
	public void m1(){
		try{
			System.out.println("1");
			return;
			//System.exit(0);//退出虚拟机
		}catch(Exception ex){
			System.out.println("2");
		}finally{
			System.out.println("3");
		}
	}
```



```java
	public int m2(){
		try{
			return 1;
		}catch(Exception ex){
			return 2;
		}finally{
			return 3;
		}
	}
```



### throw&throws

#### throw

用在代码中手工抛出异常

语法：

```java
throw new 异常类();
```

#### throws

用在方法的声明部分，告诉调用者此方法会抛出异常

语法：

```java
访问修饰符 方法(参数列表) throws 异常类型
```

对于会抛出异常的方法，方法的调用者有2个选择：

1. 调用者自己处理异常
2. 将异常继续向外抛出,假如调用者已经是main方法，建议不要再向外抛

例如：

```java
	public void m1(int i) throws IllegalArgumentException {//告知方法的调用者去处理
		if(i<0){
			throw new IllegalArgumentException("参数不能小于0");//抛出异常
		}
	}
	public void m2(){//调用抛出异常的方法,处理方式1:调用者内部消化
		try {
			m1(1);
		} catch (IllegalArgumentException e) {
			e.printStackTrace();
		}
	}
	public void m3() throws IllegalArgumentException{//调用抛出异常的方法,处理方式2:继续抛出
		m1(1);
	}
```



#### 再谈重写

在面向对象的部分，曾经提到重写的条件之一：子类不能比父类抛出更多的异常，

这里的异常局限于受检查的异常，而不包括不受检查的异常，

子类不能比父类抛出更多的异常分2种情况：

1. 父类抛异常，子类没抛异常
2. 父类抛出异常，子类抛出跟父类相同的异常或者抛出父类异常的子类

例如：

```java
class Base{
	public void m1() throws Exception{
		System.out.println("父类中的方法m1");
	}
	public void m2() throws NumberFormatException{
		System.out.println("父类中的方法m2");
	}
}
class Sub extends Base{
	//重写的条件:子类不能抛出比父类更多的异常(不包括UnCheckedException,即RuntimeException及其子类)
	public void m1() throws SQLException{
		System.out.println("子类中的方法m1");
	}
	public void m2() throws RuntimeException{
		System.out.println("子类中的方法m2");
	}
}
```



### try-with-resource结构

在JDK 7.0中，新增了try-with-resource结构，实现资源的自动关闭

实现了java.lang.AutoCloseable接口的类，就可以在try-with-resources结构里使用。

例如：

```java
public class MyAutoClosable implements AutoCloseable {
	public void doSomething() {
		System.out.println("完成某项功能");
	}
	@Override
	public void close() throws Exception {
		System.out.println("被关闭了");
	}
}
```



原先的代码：

```java
	public void test() throws Exception {
		MyAutoClosable mc=null;
		try {
			mc=new MyAutoClosable();
			mc.doSomething();
		}finally {
			if(mc!=null) {
				mc.close();
			}
		}
	}
```



try-with-resource的写法：

```java
	public void test() throws Exception {
		try(MyAutoClosable mc=new MyAutoClosable()){ //会自动调用mc的close方法
			mc.doSomething();
		}
	}
```



测试代码:

```java
	public static void main(String[] args) {
		try {
			new AutoCloseTest().test();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
```



执行结果：

```java
完成某项功能
被关闭了
```



###  自定义异常

在实际开发中，可能会遇到JDK提供的任何标准异常类都无法满足我们的需要（例如一些与业务相关的异常）

这种情况下可以创建自己的异常类，即自定义异常类。

自定义异常类只需从Exception类或者它的子类派生一个子类即可。

自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理，

如果不想处理，可以让自定义异常类继承运行时异常RuntimeException。

例如：

```java
public class NoMappingParamString extends Exception {
    /*无参构造函数*/
    public NoMappingParamString(){
        super();
    }
    //用详细信息指定一个异常
    public NoMappingParamString(String message){
        super(message);
    }
    //用指定的详细信息和原因构造一个新的异常
    public NoMappingParamString(String message, Throwable cause){
        super(message,cause);
    }
    //用指定原因构造一个新的异常
    public NoMappingParamString(Throwable cause) {
        super(cause);
    }
}
```



 自定义异常的使用与标准异常无异。

### 如何分析异常信息

当程序抛出异常时，要认真分析异常信息，从异常信息中找到问题所在

例如：

```java
	public static void main(String[] args) {
		Scanner sc=null;
    	sc=new Scanner(System.in);
		System.out.print("输入1个数：");
		String s=sc.nextLine();
		try {
			int num=Integer.parseInt(s);//可能产生异常
			System.out.println("用户输入的是:"+num);
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("try,catch后的代码");
		sc.close();
	}
```



执行时，输入一个字母，e.printStackTrace()就会在控制台打印出异常的堆栈信息

![1605161937632](image/940c33b9-b9bb-4e53-9502-a0b847b8330e.png)

通常第一行是异常的类型信息，然后是异常的抛出路径，以上面的图举例：

因为Integer类 第580行代码抛出NumberFormatException，导致Integer类第615行报错，

而Integer类第615行报错导致Demo01类的12行出错，而Demo01是自定义的类。

定位到出错行，这通常是解决问题的**第一步**，再根据异常的类型信息，就可以进行相应的修改。



## 常用类

学习 API 时，**查阅帮助文档**对学习有很大的帮助，应该尽早养成**阅读文档**的习惯。

###  包装类

所谓包装类，是相对8种基本数据类型的引用类型，其中包含了对应类型的常用属性和方法

![1605533066351](image/304550cc-7cd9-4d65-866a-92779525b611.png)

包装类和基本类型之间的转换：

基本类型->包装类： 构造函数

包装类-> 基本类型：包装类实例.xxxValue()

例如：

```java
		int i1=10;
		Integer i2=new Integer(i1);//int->Integer
		int i3=i2.intValue();//Integer->int
```



String到基本类型之间转换：包装类.parseXxx(String str)

String到包装类之间转换：包装类.valueOf(String str)，或者通过包装类的构造函数

例如：

```java
		int i1=Integer.parseInt("10"); //String->int
		Integer i2=new Integer("10"); //String->Integer
		Integer i3=Integer.valueOf("10"); //String->Integer
```



JDK 5.0以后，支持自动装箱、拆箱

装箱：基本类型 -> 包装类

拆箱：包装类 –> 基本类型

例如:

```java
		Integer i1=10;//Integer i1=Integer.valueOf(8);自动装箱
		int i2=i1;//int i2=i1.intValue();自动拆箱
```

包装类中，包含对应类型的常用属性和方法

例如：

```java
		System.out.println(Integer.toBinaryString(100)); //1100100
		System.out.println(Integer.toHexString(100)); //64
		System.out.println(Integer.toOctalString(100)); //144
		
		int n=Integer.MAX_VALUE;
		System.out.println(n+1); //最大值加1越界,-2147483648
		System.out.println(Integer.MIN_VALUE);
		if(n>n+1){
			System.out.println(true);
		}else {
			System.out.println(false);
		}
```



Integer的自动拆装箱的陷阱（整型数-128到127的值比较问题）：

代码：

```java
	public static void main(String[] args) {
		// -128--127之间
		Integer i1 = 100;
		Integer i2 = 100;
		if (i1 == i2) { //比较地址
			System.out.println("i1 == i2");
		} else {
			System.out.println("i1 != i2 ");
		}
		// 大于127
		Integer i3 = 200;
		Integer i4 = 200;
		if (i3 == i4) { //比较地址
			System.out.println("i3 == i4");
		} else {
			System.out.println("i3 != i4 ");
		}
	}
```



输出：

```java
i1 == i2
i3 != i4 
```



原因在于，在进行自动拆装箱时，编译器会使用Integer.valueof()来创建Integer实例。

以下是Integer.valueof()的源代码：

```java
  	public static Integer valueOf(int i) {
        assert IntegerCache.high >= 127;
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)]
        return new Integer(i);
    }
```



简单地解释这段代码，就是如果传入的int在IntegerCache.low和IntegerCache.high之间，那就尝试看前面的缓存

中有没有打过包的相同的值，如果有就直接返回，否则就创建一个Integer实例。

IntegerCache.low 默认是-128；IntegerCache.high默认是127。

所以如果要比较两个对象的内容是否相同，尽量不使用  == 或者  != 来比较，可以使用equals()来比较。

###  Math、Random

Math类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数

```java
	public static void main(String[] args) {
		System.out.println(Math.floor(3.14));//3
		System.out.println(Math.ceil(3.14));//4
		System.out.println(Math.round(3.14));//3
		System.out.println(Math.floor(-3.14));//-4
		System.out.println(Math.ceil(-3.14));//-3
		System.out.println(Math.round(-3.14));//-3
		//(long)Math.floor(a + 0.5d)
		System.out.println(Math.round(-3.5));//-3
		System.out.println(Math.round(-3.8));//-4
		System.out.println(Math.floor(3.5));
	}
```



获得随机数

- 通过Math类的random()方法获得随机数

![1605234179573](image/b4b6af52-bc17-433e-90d3-4faaf288ecbd.png)

![1605233900762](image/275390b7-6419-4ca6-bf36-1c2eecc33675.png)

获得从n-m的随机数，则可以：

```java
	(int)(Math.random()*(m-n+1)+n)
```

例如：

```java
	for(int i=0;i<100;i++){
		System.out.println((int)(Math.random()*91+10));//产生10-100之间的随机数
	}
```



- 通过 java.util.Random 类获得随机数

Random类根据种子值，能产生各种类型的随机数

获得从n-m的随机数，则可以：

```java
	n+new Random().nextInt(m-n+1)
```

例如：

```java
	Random r=new Random();//以当前时间的毫秒数作为种子
	//Random r=new Random(new Date().getTime());
	for(int i=0;i<10;i++){
		System.out.println(10+r.nextInt(91));//产生10-100之间的随机数
	}
```



### 日期相关类

java.util.Date：日期类

常用构造：

![1605237366624](image/28b53d5c-7f45-412e-a5c6-dbf68f180b01.png)

![1605237400986](image/2076d64e-cdd2-4e18-aa02-06f61da10239.png)

常用方法：

![1605237453625](image/0c020481-a596-43dd-a8d7-27184329baed.png)

![1605237483053](image/7c84155f-4c23-448a-a9c8-381e6b916543.png)

![1605237506163](image/0288b777-28ef-4359-a6fd-33f426c18e07.png)

例如：

```java
		//System.currentTimeMillis():当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差
		System.out.println("时间差:"+System.currentTimeMillis());
		Date d1=new Date();//当前时间
		Date d2=new Date(System.currentTimeMillis());
		System.out.println(d1);
		System.out.println(d2);
		System.out.println(d2.after(d1));
		System.out.println(d2.before(d1));
		System.out.println(d2.compareTo(d1));
		System.out.println(d1.getTime());//获取毫秒数
```



java.util.Calendar：日历类

![1605235132575](image/52f36d8b-0fa4-4b88-a401-1416ffc414bc.png)

获得Calendar的实例：

```java
		Calendar c=Calendar.getInstance();//获取日历类的实例
```



Calendar.getInstance()部分源码：

```java
		if (cal == null) {
            if (aLocale.getLanguage() == "th" && aLocale.getCountry() == "TH") {
                cal = new BuddhistCalendar(zone, aLocale);
            } else if (aLocale.getVariant() == "JP" && aLocale.getLanguage() == "ja"
                       && aLocale.getCountry() == "JP") {
                cal = new JapaneseImperialCalendar(zone, aLocale);
            } else {
                cal = new GregorianCalendar(zone, aLocale);
            }
        }
```



默认情况下返回的是GregorianCalendar，GregorianCalendar表示阳历

常用方法：

![1605237606923](image/61573736-2297-46b7-929f-483d174505c1.png)

获得某个日历字段的值：

![1605237653151](image/cc175dfa-276c-4396-ab1c-123c9d6e8e13.png)

Calender转换成Date

![img](image/a5654800-a4f5-4b04-9c2d-8ab05103d324.png)

重新设置Calender里的时间

![1605237736186](image/d127adaf-6b19-4c73-93e8-5dd017025df6.png)

设置某个Date的时间为Calendar的时间

![1605237761430](image/99f41b7b-6ff8-473f-9952-c160e0877162.png)

例如：

```java
		Calendar c=Calendar.getInstance();//获取实例
		c.add(Calendar.MONTH, -2);
		c.clear();
		//c.set(2020, 6, 5, 8, 6, 15);//设置时间
		Date d1=new Date();//当前时间
		c.setTime(d1);//date->Calendar
		//取出时间字段
		System.out.println(c.get(Calendar.YEAR));
		System.out.println(c.get(Calendar.MONTH)+1);
		System.out.println(c.get(Calendar.DATE));
		System.out.println(c.get(Calendar.HOUR_OF_DAY));//24小时制的小时
		System.out.println(c.get(Calendar.MINUTE));
		System.out.println(c.get(Calendar.SECOND));
		System.out.println(c.get(Calendar.DAY_OF_MONTH));//几号
		System.out.println(c.get(Calendar.DAY_OF_WEEK));//星期几
		Date d3=c.getTime();//Calendar->date
```



JDK8.0中新增了一些日期类，均位于java.time包下

* Instant（时间戳）；
 * LocalDate（日期）；
 * LocalDateTime（日期时间）；
 * ZonedDateTime（带有区域信息的日期时间，比如中国默认使用的是东八区）；
 * Period（如两个日期之间相差的天数）；
 * Druation（两个日期时间之间间隔的秒和纳秒）。

例如：

```java
		Instant now = Instant.now();
		System.out.println(now.toString()); // 2020-08-06T09:44:13.677Z (utc时间格式)
		System.out.println(now.get(ChronoField.MILLI_OF_SECOND)); // 毫秒 
		System.out.println(now.get(ChronoField.MICRO_OF_SECOND)); // 微秒 
		System.out.println(now.get(ChronoField.NANO_OF_SECOND)); // 纳秒 
		System.out.println(ZoneId.systemDefault()); // 获取系统默认时区:Asia/Shanghai
		
		LocalDate localDate = LocalDate.now(); //当前时间
		System.out.println(localDate); // 2018-08-06
		LocalDateTime localDateTime 
			= LocalDateTime.ofInstant(now, ZoneId.systemDefault());//当前日期及时间
		System.out.println(localDateTime); // 2018-08-06T17:44:13.677

		// 获得当前日期
		LocalDate localDate1 = LocalDate.now();
		System.out.println(localDate1.toString());
		// 日期加上1天
		LocalDate localDate2 = localDate1.plusDays(1);
		System.out.println(localDate2.toString());
		// 日期加上一周
		LocalDate localDate3 = localDate1.plusWeeks(1);
		System.out.println(localDate3);
		// 计算当前年的第52天是几月几号
		System.out.println("今年的第52天 = " + localDate1.withDayOfYear(52));

		// 只处理时间
		LocalTime localTime = LocalTime.now();
		System.out.println("local time = " + localTime);
		System.out.println("plus 12 hours = " + localTime.plusHours(12));

		/*
		 * Period Period代表的是两个日期之间的天、月、年数差值，
		 * 当然，我们也可以直接使用LocalDate中的until方法来完成同样的效果。
		 */

		LocalDate startDate = LocalDate.now();
		LocalDate endDate = startDate.plusDays(1);

		Period period = Period.between(startDate, endDate);
		System.out.println("间隔的天数" + period.getDays());
		System.out.println("间隔的月数:" + period.getMonths());
		System.out.println("间隔的年数:" + period.getYears());

		// 直接使用日期类中的方法计算日期间隔
		long days = startDate.until(endDate, ChronoUnit.DAYS);
		System.out.println("间隔的天数:" + days);
		long weeks = startDate.until(endDate, ChronoUnit.WEEKS);
		System.out.println("间隔的周数:" + weeks);

		/* Duration表示的是两个日期时间间隔的秒以及纳秒数。 */
		LocalDateTime start = LocalDateTime.now();
		LocalDateTime end = start.plusDays(1);
		Duration duration = Duration.between(start, end);
		System.out.println("间隔的秒数:" + duration.get(ChronoUnit.SECONDS));
		// System.out.println("间隔的毫秒数:" + duration.get(ChronoUnit.MICROS));
		System.out.println("间隔的纳秒数:" + duration.get(ChronoUnit.NANOS));
```



### Object

常用方法：

![1605237218209](image/62a489c7-871d-4ce6-8ffb-218c7760bb57.png)

![1605238558808](image/5bb0927d-e8b3-4c6e-896e-450812898892.png)

Object的equals()和==是一样的，比较的是地址，如要实现自定义的比较规则，则需重写此方法。

例如，String类重写了equals方法，比较的2个字符串的内容是否相等。

```java
	public boolean equals(Object anObject) {
        if (this == anObject) { //假如二者地址相等
            return true;//地址相同，返回真
        }
        if (anObject instanceof String) { //判断其类型是否为String
            String anotherString = (String)anObject; //向下转型为String
            int n = value.length; //获取当前字符串的长度
            if (n == anotherString.value.length) { //判断2个字符串的长度是否相等
                char v1[] = value; //取出当前字符串的char数组
                char v2[] = anotherString.value; //获得被比较的字符串的char数组
                int i = 0;
                while (n-- != 0) { //通过循环，依次比较每个位置上的字符
                    if (v1[i] != v2[i]) //假如某个字符不同
                        return false; //返回假
                    i++;
                }
                return true; //所有位置的字符都相同，返回真
            }
        }
        return false; //被比较对象不是String,返回假
    }
```

 

自定义类实现equals的例子：

```java
public class Stu{
	private Integer stuAge;
	private String stuName;
	private String stuNo;
	public Stu() {}
	public Stu(String stuNo, String stuName, Integer stuAge) {
		super();
		this.stuNo = stuNo;
		this.stuName = stuName;
		this.stuAge = stuAge;
	}
	@Override
	public boolean equals(Object obj) { //根据学号判断2个学生是否相同
		if(obj instanceof Stu){
			return this.stuNo.equals(((Stu)obj).getStuNo());
		}
		return false;
	}
	//getXxx,setXxx省略
}
```



![1605239775693](image/80a35e8e-0d8e-46e1-9401-18a70e1db1fa.png)

![1605239809522](image/bed3f3ed-3c4a-4f7b-aa1a-fe3e7ccd1664.png)

当直接将对象传入System.out.println()时，默认会调用其toString()，输出其字符串表示，所以可以重写toString()

方法，打印自定义的信息。

例如：

```java
	@Override
	public String toString() {
		return "Stu [stuAge=" + stuAge + ", stuName=" + stuName + ", stuNo=" + stuNo + "]";
	}
```



### String类

#### 字符串常量池

字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字

符串，极大程度地影响程序的性能，虚拟机为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些

优化

- 为字符串开辟一个字符串常量池，类似于缓存区
- 创建字符串常量时，首先检查字符串常量池是否存在该字符串
- 存在该字符串，直接返回引用，不存在，实例化该字符串并放入池中

代码中的有哪些常量在编译时确定，存放于class文件中，在class文件加载时，在内存中建立常量池。

例如：

```java
		//写法1：常量池中，1个
		String s1="tom";//指向常量池中字符串常量"tom"
		String s2="tom";//指向常量池中字符串常量"tom"
		//写法2：常量池中，1个; 堆里，1个
		String s3=new String("tom");//在堆中创建tom的一个副本,s3中是副本的地址
		//对String类,==比较的是地址, equals()比较的是值
		System.out.println(s1==s2);//true
		System.out.println(s1==s3);//false
		System.out.println(s1.equals(s2));//true
		System.out.println(s1.equals(s3));//true
		String s4="t"+"o"+"m";//编译时自动合并,等价于s4="tom"
		String s5="to"+"m";//编译时自动合并,等价于s5="tom"
		String s6="t"+"om";//编译时自动合并,等价于s6="tom"
		System.out.println(s1==s4);//true
		System.out.println(s1==s5);//true
		System.out.println(s1==s6);//true
		String s7="t";
		String s8=s7+"om";//s7是变量,不能合并
		System.out.println(s1==s8);//false
```



#### 与char[]和byte[]之间的转换

String 的数据是保存在内部的一个char[]数组中：

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[]; //保存数据	  
```

String -> char[] 的转换

![1605248389019](image/41dd4628-ef87-44b2-8545-412300aa2166.png)

char[] ->String 转换：

![1605248424810](image/17ae8989-76e8-49df-8dce-f997e5190de5.png)

例如:

```java
		System.out.println(Charset.defaultCharset());//当前系统默认字符集
		String s="123abc中国";//内部采用unicode编码	
		char[] vals=s.toCharArray();//String->char[]
		System.out.println(vals.length);
		for(char c:vals){
			System.out.println(c);
		}
		char[] c={'A','B','c'};
		String s1=new String(c);//char[]->String	
```



![1605250364143](image/89c298d9-07a1-4868-bb26-c4ffa28a14de.png)

虚拟机内部的字符只有1种字符集：Unicode，当字符数据要保存到虚拟机外部的某个文件里，或要在网络上进行

传输，此时则要采用特定的字符集进行编码 (String --> byte[]) 和解码 (byte[] --> String) 的操作。

String -> byte[] 之间的转换

![1605248456285](image/c1a3469d-b2b8-44b0-9039-e7c11f262602.png)

byte[] –> String转换：

![1605248513503](image/be4590c7-b4d6-4c61-9fcd-d97e0ee12310.png)

例如：

```java
		//String->byte[] 编码
		byte[] bs=s.getBytes();//采用默认字符集进行编码
		System.out.println(bs.length);
		for(byte b:bs){
			System.out.println(b);
		}
		//byte[]->String 解码
		String str=new String(bs,"iso-8859-1");//错误的解码
		System.out.println(new String(str.getBytes("iso-8859-1"),"utf-8"));//恢复	
```



#### 字符串常用方法

```java
		String str="public static void main";
		System.out.println(str.charAt(8));//t
		System.out.println(str.concat("()"));//public static void main()
		System.out.println(str.contains("static"));//true
		System.out.println(str.endsWith("n"));//true
		System.out.println(str.startsWith("public"));//true
		System.out.println(str.equals("public static void main"));//true
		System.out.println(str.equalsIgnoreCase("PUBLIC static void main"));//true
		System.out.println(str.indexOf(97));//9
		System.out.println(str.indexOf('a',10));//20
		System.out.println(str.indexOf("ic"));//4
		System.out.println(str.indexOf("ic",7));//11
		System.out.println(str.lastIndexOf("ic"));//11
		System.out.println(str.lastIndexOf("ic",7));//4
		System.out.println(str.length());//23
		System.out.println(" ".trim().isEmpty());//true
		System.out.println(str.replace('i', '8'));//publ8c stat8c vo8d ma8n
		System.out.println(str.replace("ic", "666"));//publ666 stat666 void main
		System.out.println(str.replaceAll("[ai]", "9"));//publ9c st9t9c vo9d m99n
		System.out.println(str.replaceFirst("[ai]", "9"));//publ9c static void main
		String[] words=str.split(" ");//[public,static,void,main]
		for(String w:words) {
			System.out.println(w);
		}
		System.out.println(str.substring(7));//static void main
		System.out.println(str.substring(7,13));//static
		System.out.println(str);//public static void main
```



#### String是不可变字符串

String的源码：

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[]; //保存数据
```

从源代码中可以看到其内部用来存储数据的数组前有final修饰，也就意味着String一旦赋值就不能再修改。

假如程序中某个字符数据会频繁发生变化，此时使用String会导致每一次变化产生一个新的字符串，内存开销较

大，此时应该使用可变字符串：StringBuffer或者StringBuilder

例如：

```java
		StringBuffer sb=new StringBuffer("");
		for(int i=0;i<100;i++){
			sb.append(i);//添加到后面,不会产生新字符串
		}
		System.out.println(sb.toString());//toString():转成字符串
```



二者之间的区别是：StringBuffer是线程安全的，StringBuilder线程不安全。



### 格式化类

java.text.SimpleDateFormat: 日期格式化类

![1605252938448](image/05153943-379d-4551-bd06-bf202df86cc9.png)

例如：

```java
		Date d=new Date();
		System.out.println(d);//以默认格式打印
		SimpleDateFormat simpleFormat=new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
		String str=simpleFormat.format(d);//按照指定的格式将Date转成String
		System.out.println("按照yyyy年MM月dd日 HH:mm:ss格式转成的字符串:"+str);
		String source="2020-08-09 06:05:09";
		simpleFormat.applyPattern("yyyy-MM-dd hh:mm:ss");//重新设置格式
		Date d1=null;
		try {
			d1 = simpleFormat.parse(source);//String->Date
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println(d1);
```



JDK8.0中，新增了java.time.format.DateTimeFormatter类

例如：

```java
		// 字符串转日期
		DateTimeFormatter strToDateFormatter 
			= DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
		TemporalAccessor dateTemporal = strToDateFormatter.parse("2017-01-01 13:00:00");
		LocalDate date = LocalDate.from(dateTemporal);
		System.out.println(date);
		LocalDateTime dateTime 
			= LocalDateTime.parse("2017-01-01 13:00:00", strToDateFormatter);
		System.out.println(dateTime.toString());

		// 格式化日期
		LocalDateTime localDateTime1 = LocalDateTime.now();
		DateTimeFormatter dateToStrFormatter 
			= DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
		String dateStr = dateToStrFormatter.format(localDateTime1);
		System.out.println(dateStr);
```



数值格式化类：java.text.DecimalFormat

![1605253300002](image/1f896031-80fb-4499-a277-297f15a03a21.png)

例如：

```java
		double d=3.1415926;
		DecimalFormat df=new DecimalFormat("00.00");
		System.out.println(df.format(d));
		df.applyPattern("##.##%");
		System.out.println(df.format(d));
		d=900000;
		df.applyPattern("000,000.00");
		System.out.println(df.format(d));
		df.applyPattern("¤000,000.00");
		System.out.println(df.format(d));
		df.applyPattern("000,000.00吨");
		System.out.println(df.format(d));
		df.applyPattern("00E0");
		System.out.println(df.format(d));
```



### 数组工具类Arrays

常用方法：

![1605253449138](image/f65840f1-22eb-41de-b036-c3f834360f1f.png)

![1605253477763](image/6c1c2738-840e-46c8-be00-5aa8953d2fb5.png)

![1605253498306](image/c058a92b-2057-4b6c-a4dd-4848dfab7f65.png)

![1605253590220](image/53ab23f6-b669-4bc9-b116-c3b910992ad4.png)

![1605253623621](image/894be656-92e2-4e8d-8a05-64649f6c02d7.png)

例如：

```java
		int[] as={10,20,68,30,3,2};
		Arrays.sort(as);//排序
		int[] newArray=Arrays.copyOf(as, 10);//扩容
		Arrays.fill(newArray, 6, 10, 999);//填充
		System.out.println(Arrays.toString(newArray));//转成字符串输出
		int index=Arrays.binarySearch(newArray, 68);//二分查找
		System.out.println("6所在位置："+index);//5
```



## IO：Input/Output

### File操作

构造函数：

![1605442597039](image/c50edebc-a9fa-4fa0-b0ba-6ff293a5eea1.png)

常用方法：

- 文件信息

![1605442940604](image/d1201847-7073-428e-85ad-50f278ca6f48.png)

![1605442985818](image/b89fed1f-83bf-44b3-88d9-da4c7941123e.png)

- 文件修改

![1605443031241](image/c21b007a-b1ff-4dd1-9d0b-8dff4aa46dd6.png)

![1605443054033](image/133bb491-250a-46ea-b74c-3949cf8e51cb.png)

- 目录操作

![1605443090514](image/8eefe24d-d4aa-40b1-9f65-bb7e948dd653.png)

![1605443118221](image/d1070d5d-8415-4669-986e-a23c35180c29.png)

- 文件测试

![1605443160386](image/f07abce4-11ba-434c-9e89-f81d64104a3e.png)

![1605443181553](image/b2d0837a-eb14-4298-95e3-6a0271f9779d.png)

![1605443216339](image/31f44f02-80a1-4de9-b6d4-9216e23ab88e.png)

 例如：

```java
		//String userDir=System.getProperty("user.dir");//获得当前工作目录
		//File file=new File(userDir,"test");//采用绝对路径,绝对路径=parent+child
		File file=new File("test");//采用相对路径,默认相对：工作目录
		if(file.exists()){//判断文件或者目录是否存在
			if(file.isFile()){//判断是否为文件
				System.out.println("是文件");
				System.out.println(new Date(file.lastModified()));
				System.out.println(file.length());
			}else{
				System.out.println("是目录");
			}
			System.out.println(file.getName());
			System.out.println(file.getPath());
			System.out.println(file.getAbsolutePath());
			System.out.println(file.getParent());
		}
```



```java
		File file=new File("Other.java");
		File newFile=new File("test","Hello.java");
		file.renameTo(newFile);//1.目录没换,改名  2.目录改变,移动文件
		newFile.delete();//删除文件
		File otherFile=new File("other");
		if(!otherFile.exists()){
			otherFile.mkdir();//创建目录
			//file.mkdirs();//同时创建多级目录
		}
```



文件过滤器，返回符合条件的File数组

- java.io.FileFilter

例如:

```java
        //定义一个FileFilter的实现类,定义过滤规则
        class MyFilter implements FileFilter{
            @Override
            public boolean accept(File file) {
                if(file.isFile()){
                    return file.getName().endsWith(".exe");//过滤规则:扩展名为exe的可执行文件
                }
                return false;
            }
        }
```



测试：

```java
		File file=new File("D:\\工具软件");
		File[] fs=file.listFiles(new MyFilter()); //返回所有可执行文件
		for(File f:fs){
			System.out.println(f.getName());
		}
```



- java.io.FilenameFilter

例如：

```java
        //定义一个FilenameFilter的实现类,定义过滤规则
        class MyNameFilter implements FilenameFilter{
            @Override
            public boolean accept(File dir, String name) {
                return name.endsWith(".exe");
            }
        }
```



测试：

```java
		File file=new File("D:\\工具软件");
		File[] fs=file.listFiles(new MyNameFilter());//返回所有可执行文件
		for(File f:fs){
			System.out.println(f.getName());
		}
```



### 常用IO流

从三个不同的角度可以对流进行分类

1. 从流的方向

   输入流：站在内存的角度，将数据从硬盘读到内存里

   输出流：将数据从内存写到硬盘的文件里

2. 从流操作数据时采用的单位

   字节流：以字节为单位处理数据

   字符流：以字符为单位处理数据

3. 从流的实现方式


   节点流：直接操作数据的流

   处理流：在某个节点流或者处理流的基础之上，进行进一步的封装，提供更高级的方法的流，也称为包装流

![1605533111172](image/f9a5f29f-8f22-47b9-b2fe-558921b671f3.png)

流的层次结构：

![1605533141392](image/d0c1426a-0639-44da-81e3-46a7896af16e.png)

![1605533178789](image/c6750235-f016-43a5-b6b0-ce611341d32c.png)



![1605533203836](image/71b1a052-baa9-421e-acbd-6b98f941bd3d.png)



文件字节流

##### FileInputStream:

构造函数：

![1605493001106](image/fda605ad-ad2f-4ea2-91a0-78e9df6dd079.png)

常用方法：

![1605493083644](image/f48cb4e4-3b6d-4ec4-a7e2-ac3352246907.png)

一次读取一个字节，将读取的数据作为返回值返回，读不到返回-1

例如：

```java
		InputStream in=null;
		try {
			in=new FileInputStream("data.txt");//文件字节输入流 
			int data=in.read();//读取第1个字节
			while(data!=-1){//判断是否读到文件尾
				System.out.print((char)data);//先处理上次读取的数据
				data=in.read();//再读下一次
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			try {
				if(in!=null)
					in.close();//关闭流
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
```



![1605493662436](image/3ce926c2-a061-45a2-bffa-f533f3dc4d0b.png)

一次将一组数据读入缓冲数组中，返回的是本次读取的字节数

例如：

```java
		InputStream in=null;
		try {
			in=new FileInputStream("data.txt");//文件字节输入流
			byte[] buffer=new byte[5];//定义一个缓冲数组
			int length=in.read(buffer);//读取第1次
			while(length!=-1){//判断是否读到文件尾
				//先处理上次读取的数据
				for(int i=0;i<length;i++){//不能用i<buffer.length;最后一次大概率读不满
					System.out.print((char)buffer[i]);
				}
				length=in.read(buffer);//再读下一次
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			try {
				if(in!=null)
					in.close();//关闭流
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
```



![1605493943418](image/d2543f9e-5d82-4a90-838b-c40b21528cee.png)

一次将一组数据读入缓冲数组中，返回的是本次读取的字节数

第2个参数表示将数据放入缓冲数组时，从哪个位置开始存放

第3个参数表示读取的最大字节数

例如：

```java
		InputStream in=null;
		try {
			in=new FileInputStream("data.txt");//文件字节输入流
			byte[] buffer=new byte[5];//定义一个缓冲数组
			int length=in.read(buffer,0,buffer.length);//读取第1次
			while(length!=-1){//判断是否读到文件尾
				//先处理上次读取的数据
				for(int i=0;i<length;i++){//不能用i<buffer.length;最后一次大概率读不满
					System.out.print((char)buffer[i]);
				}
				length=in.read(buffer,0,buffer.length);//再读下一次
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			try {
				if(in!=null)
					in.close();//关闭流
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
```



##### FileOutputStream:

构造函数：

![1605497303328](image/a216ebaa-dd85-4fe3-8e5f-4908603c4e97.png)

双参构造中的第2个参数append如果为 true，表示将字节写入文件末尾处(追加)，而不是写入文件开始处(覆盖)

常用方法：

![1605497403268](image/dfb2b8fa-d88a-4af2-9715-92244f053c30.png)

结合使用文件输入流和文件输出流，实现文件的拷贝

 例如：

```java
		InputStream in=null;//输入流
		OutputStream out=null;//输出流
		try {
			in=new FileInputStream("66.jpg");
			out=new FileOutputStream("copy.jpg");
			byte[] buf=new byte[1024];//缓冲数组
			int length=in.read(buf, 0, buf.length);//读取第1次
			while(length!=-1){//本次读到数据
				out.write(buf, 0, length);//写出数据
				length=in.read(buf, 0, buf.length);//读下一次
			}
		} catch (IOException e) {
			e.printStackTrace();
		}finally{//释放资源
			try {
				if(in!=null)
					in.close();
			} catch (IOException e) {
				e.printStackTrace();
			}finally{
				try {
					if(out!=null)
						out.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
```



#### 字符转换流

##### InputStreamReader

InputStreamReader 是字节流通向字符流的桥梁：它使用指定的 [charset]() 读取字节并将其解码为字符。它使用的字

符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。 

构造函数：

![1605498351193](image/761efe62-4eb1-4657-b0f9-3e082188fd9d.png)

例如：

```java
		InputStream in=null;
		Reader r=null;
		try {
			in=new FileInputStream("test.doc");
			r=new InputStreamReader(in,"utf-8");//字节流到字符流之间的桥梁
			int data=r.read();//读第1个字符
			while(data!=-1){//本次是否读到
				System.out.println((char)data);//控制台输出
				data=r.read();//读下1个字符
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			try {
				if(r!=null){
					r.close();
				}
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
```



##### OutputStreamWriter

构造函数：

![1605505273499](image/6308a10f-0c3e-40e2-a8b5-b1f279ad937b.png)

结合InputStreamReader完成文件的编码转换

例如:

```java
		InputStream in=null;
		OutputStream out=null;
		InputStreamReader reader=null;
		OutputStreamWriter writer=null;
		try {
			in=new FileInputStream("gbk.txt");
			reader=new InputStreamReader(in,"GBK");//用GBK读取
			out=new FileOutputStream("taget.txt");
			writer=new OutputStreamWriter(out,"UTF-8");//用UTF-8输出
			char[] buf=new char[2];
			int length=reader.read(buf, 0, buf.length);
			while(length!=-1){
				writer.write(buf, 0, length);
				length=reader.read(buf, 0, buf.length);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				if(reader!=null)
					reader.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}finally{
				try {
					if(writer!=null){
						writer.close();
					}
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
```



#### 字符流

##### FileReader

用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。

构造函数：

![1605505677330](image/458918dc-3a2f-4848-8d46-a0f70a6191a1.png)

FileReader的源码：

```java
public class FileReader extends InputStreamReader {

   /**
    * Creates a new <tt>FileReader</tt>, given the name of the
    * file to read from.
    *
    * @param fileName the name of the file to read from
    * @exception  FileNotFoundException  if the named file does not exist,
    *                   is a directory rather than a regular file,
    *                   or for some other reason cannot be opened for
    *                   reading.
    */
    public FileReader(String fileName) throws FileNotFoundException {
        super(new FileInputStream(fileName));
    }
```

其本质上就是InputStreamReader的便捷类

##### FileWriter

用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。

构造函数：

![1605506085239](image/40c41d0b-c94d-41b3-9341-5880145603e1.png)

其本质上就是OutputStreamWrier的便捷类

例如：

```java
		FileReader fr=null;
		FileWriter fw=null;
		try {
			fr=new FileReader("utf8.txt");
			fw=new FileWriter("other.txt");
			System.out.println(fr.getEncoding());
			for(int data=fr.read();data!=-1;data=fr.read()){
				fw.write(data);
			}
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}finally{
			try {
				if(fr!=null)
					fr.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}finally{
				try {
					if(fw!=null)
						fw.close();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
```



#### 缓冲流

##### BufferedReader

特点：从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取

构造函数:

![1605506543614](image/59125191-199c-4fb3-b0f7-497ce28c48a2.png)

从BufferedReader源代码可以看到其默认缓冲区大小为8KB

```java
private static int defaultCharBufferSize = 8192; //默认缓冲区大小8KB
	public BufferedReader(Reader in, int sz) {//采用传入的的缓冲区大小
        super(in);
        if (sz <= 0)
            throw new IllegalArgumentException("Buffer size <= 0");
        this.in = in;
        cb = new char[sz];
        nextChar = nChars = 0;
    }

    /**
     * Creates a buffering character-input stream that uses a default-sized
     * input buffer.
     *
     * @param  in   A Reader
     */
    public BufferedReader(Reader in) {//采用默认的缓冲区大小
        this(in, defaultCharBufferSize);
    }
```



常用方法：

![1605506911404](image/e2d73125-18e7-413e-a64d-04522e8d0df5.png)

##### BufferedWriter

将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 

构造函数：

![1605506806040](image/830d0e93-6b39-41e7-8f72-85526b2e1f2d.png)

常用方法：

![1605507010555](image/81619eb9-35a2-42ba-a1d1-8bd7e9b19703.png)

在其接口Writer中定义的方法：

![1605507128098](image/ca7e6b79-9f8a-4479-a3c5-5d654c65a8b9.png)

 例如:

```java
		FileReader fr=null;
		BufferedReader br=null;
		OutputStreamWriter writer=null;
		BufferedWriter bw=null;
		try {
			writer=new OutputStreamWriter(
					new FileOutputStream("other.txt"),"utf-8");
			bw=new BufferedWriter(writer);
			fr=new FileReader("utf8.txt");
			br=new BufferedReader(fr);
			String s=br.readLine();//读取一行
			while(s!=null){
				bw.write(s);
				s=br.readLine();
				if(s!=null)
					bw.newLine();//输出换行符
			}
			bw.flush();//清空缓冲区里的内容
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}finally{
			try {
				if(br!=null){
					br.close();
				}
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}finally{
				try {
					if(bw!=null){
						bw.close();
					}
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
```



#### 序列化

序列化：将对象写入到IO流中

反序列化：从IO流中恢复对象

**意义**：序列化机制允许将Java对象转换为字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，

以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。

**使用场景**：所有可在网络上传输的对象都必须是可序列化的，传入的参数或返回的对象都是可序列化的，

否则会出错；所有需要保存到磁盘的java对象都必须是可序列化的。

**实现方式**：实现**Serializable**接口，通常建议，程序创建的每个JavaBean类都实现Serializeable接口。

##### ObjectOutputStream

ObjectOutputStream主要实现序列化

构造函数：

![1605513239702](image/0ea17f56-c0f1-4ec6-9d5c-6b79487119e2.png)

常用方法：

![1605513394613](image/6f615adb-e89c-49d8-8e82-70b5a286a295.png)

例如：

```java
        class A implements Serializable{
            float j=100;
        }
```

序列化：

```java
		try {
			// TODO Auto-generated method stub
			A a=new A();
			ObjectOutputStream out
				=new ObjectOutputStream(new FileOutputStream("a.dat"));
			out.writeObject(a);//将内存中的对象写到文件中,序列化
			out.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
```



如果一个可序列化的类的成员是引用类型，那这个引用类型也必须是可序列化的；否则，会导致此类不能序列化。

##### ObjectInputStream

ObjectInputStream主要实现反序列化

构造函数：

![1605513807119](image/76554321-44b4-4cc0-b045-d7cc1ade774f.png)

常用方法：

![1605513867811](image/da96d745-46e4-4ee5-8826-7b106b37a68c.png)

反序列化：

```java
		try {
			ObjectInputStream in
				=new ObjectInputStream(new FileInputStream("a.dat"));
			A a=(A)in.readObject();
			System.out.println(a.i);
			System.out.println(a.j);
			in.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
```



##### 可选择的序列化

有些时候，我们有这样的需求，某些属性不需要序列化。使用transient关键字选择不需要序列化的字段。

使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是

默认值。对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。

例如：

```java
class A implements Serializable{
	transient int i=10;//transient:瞬时,不参与序列化;反序列化时为默认值
	float j=100;
}
```



##### 序列化版本号serialVersionUID

我们知道，反序列化必须拥有class文件，但随着项目的升级，class文件也会升级，序列化怎么保证升级前后的兼

容性呢？java序列化提供了一个private static final long serialVersionUID 的序列化版本号，只有版本号相同，即

使更改了序列化属性，对象也可以正确被反序列化回来。

如果反序列化使用的class的版本号与序列化时使用的不一致，反序列化会报InvalidClassException异常。

序列化版本号可自由指定，如果不指定，JVM会根据类信息自己计算一个版本号，这样随着class的升级，就无法

正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能

计算的规则不一样，这样也会导致无法反序列化。

例如：

```java
class A implements Serializable{
	private static final long serialVersionUID = 66666L;
	transient int i=10;//transient:瞬时,不参与序列化;反序列化时为默认值
	float j=100;
}
```



先进行序列化，然后修改其serialVersionUID：

```java
class A implements Serializable{
	private static final long serialVersionUID = 88888L;
	transient int i=10;//transient:瞬时,不参与序列化;反序列化时为默认值
	float j=100;
}
```



此时再进行反序列化则会报InvalidClassException异常

#### 打印流

特点：将各种类型的数据转换成String输出

部分转换成String的源代码：

```java
 	public void print(int i) {
        write(String.valueOf(i));
    }

    public void print(long l) {
        write(String.valueOf(l));
    }

    public void print(float f) {
        write(String.valueOf(f));
    }

    public void print(double d) {
        write(String.valueOf(d));
    }
```



##### PrintStream：

字节打印流，System.out返回的就是一个PrintStream

##### PrintWriter

字符打印流，PrintStream打印的所有字符都使用平台的默认字符编码转换为字节，所以一般用于二进制文件（文

本文件也是可以的），在需要写入字符而不是写入字节的情况下，应该使用PrintWriter类。 

另外，在自动刷新方面，PrintStream在遇到换行符的时候就会自动刷新，即在调用了println()方法，或者文本中

出现“\n”，就会自动flush，PrintWriter则不会，要在构造方法中设置自动刷新，或者手动flush。

 例如：

```java
		try {
			PrintWriter pw=new PrintWriter("02.txt");
			pw.print(1);
			pw.print(3.2);
			pw.print(true);
			pw.print('中');
            pw.flush();
			pw.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
```



#### java.io.RandomAccessFile

此类的实例支持对随机访问文件的读取和写入

构造函数：

![1605517225552](image/728715bf-ddb8-41fd-a078-b12ac9442a55.png)

 常用mode：

"r"：以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。 

"rw"：打开以便读取和写入。如果该文件尚不存在，则尝试创建该文件。 

控制文件指针的位置:

![1605517310893](image/b2696d4b-544d-465a-8280-95a23648bcc6.png)

![1605517334561](image/48f3d5be-e517-4d2e-bad4-8e4d141567af.png)

写文件:

```java
		try {
			RandomAccessFile ras1=new RandomAccessFile("data.dat","rw");
			ras1.writeInt(20);//写入4个字节
			ras1.writeUTF("中国");//写入8个字节，前2个字节是长度，后面6个字节是数据
			ras1.writeChars("中国");//写入2个字符，4个字节
			ras1.writeFloat(3.2F);//写入4个字节
			ras1.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
```



写入后的文件数据：

![1605533375760](image/682a89ea-fe8b-40bc-a215-23f7d31f22f7.png)

 

读文件：

```java
		try {
			RandomAccessFile ras2=new RandomAccessFile("data.dat","r");
			ras2.skipBytes(4);//跳过前4个字节
			System.out.println(ras2.readUTF());//中国
			System.out.println(ras2.readChar());//读1个字符：中
			System.out.println(ras2.readChar());//读1个字符：国
			System.out.println(ras2.readFloat());//3.2
			ras2.seek(0);//回到起始位置
			System.out.println(ras2.readInt());//20
			ras2.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
```